<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>3D Model Head Tracking</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background: #222;
            color: white;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        
        #camera-panel {
            width: 320px;
            padding: 20px;
            background: #333;
            transition: transform 0.3s ease;
            flex-shrink: 0;
            position: relative;
            z-index: 10;
            overflow-y: auto;
            height: 100vh;
        }
        
        #camera-panel.hidden {
            transform: translateX(-100%);
            position: absolute;
        }
        
        #toggle-panel {
            position: fixed;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            background: #555;
            color: white;
            border: none;
            padding: 10px 8px;
            cursor: pointer;
            z-index: 1000;
            border-radius: 0 8px 8px 0;
            transition: left 0.3s ease;
            width: auto;
            margin: 0;
            font-size: 16px;
        }
        
        #toggle-panel:hover {
            background: #666;
        }
        
        #toggle-panel.panel-hidden {
            left: 0;
        }
        
        #toggle-panel.panel-visible {
            left: 360px;
        }
        
        #video {
            width: 100%;
            border: 2px solid #555;
            border-radius: 8px;
            position: relative;
        }
        
        #video-container {
            position: relative;
            width: 100%;
        }
        
        #three-container {
            flex: 1;
            position: relative;
            width: 100%;
            height: 100vh;
        }
        
        #status {
            margin-top: 10px;
            padding: 10px;
            background: #444;
            border-radius: 4px;
            font-size: 12px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #555;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background: #666;
        }
        
        input[type="file"] {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #555;
            color: white;
            border: none;
            border-radius: 4px;
        }
        
        .section {
            margin: 15px 0;
            padding: 10px;
            background: #444;
            border-radius: 4px;
        }
        
        .section h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        
        #head-dot {
            position: absolute;
            width: 10px;
            height: 10px;
            background: red;
            border-radius: 50%;
            display: none;
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <button id="toggle-panel" class="panel-visible">◀</button>
    <div id="camera-panel">
        <div id="video-container">
            <video id="video" autoplay muted></video>
            <div id="head-dot"></div>
        </div>
        <canvas id="canvas" style="display: none;"></canvas>
        
        <div class="section">
            <h3>Camera</h3>
            <select id="cameraSelect" style="width: 100%; padding: 10px; margin: 5px 0; background: #555; color: white; border: none; border-radius: 4px;">
                <option value="">Select Camera...</option>
            </select>
            <button onclick="startCamera()">Start Camera</button>
            <button onclick="calibrate()">Calibrate (Press Space)</button>
        </div>
        
        <div class="section">
            <h3>3D Model</h3>
            <input type="file" id="modelFile" accept=".glb,.gltf" onchange="loadModel(event)">
            <button onclick="resetModel()">Reset Model</button>
            <button onclick="createDefaultCube()">Default Cube</button>
        </div>
        
        <div class="section">
            <h3>Head Tracking</h3>
            <label><input type="checkbox" id="sameSensitivity"> Same Value</label>
            <label><input type="checkbox" id="invertX"> Invert X</label>
            <label><input type="checkbox" id="invertY"> Invert Y</label><br/>
            
            <label for="sensitivityX">Sensitivity X: <span id="sensitivityXValue">60</span></label>
            <input type="range" id="sensitivityX" min="10" max="120" value="60" style="width: 100%; margin: 5px 0;">
            
            <label for="sensitivityY">Sensitivity Y: <span id="sensitivityYValue">40</span></label>
            <input type="range" id="sensitivityY" min="10" max="120" value="40" style="width: 100%; margin: 5px 0;">
            
            <label for="offsetX">Offset X: <span id="offsetXValue">0</span></label>
            <input type="range" id="offsetX" min="-160" max="160" value="0" style="width: 100%; margin: 5px 0;">
            
            <label for="offsetY">Offset Y: <span id="offsetYValue">0</span></label>
            <input type="range" id="offsetY" min="-120" max="120" value="0" style="width: 100%; margin: 5px 0;">
        </div>
        
        <div class="section">
            <h3>Camera Setup</h3>
            <select id="cameraPreset" style="width: 100%; padding: 10px; margin: 5px 0; background: #555; color: white; border: none; border-radius: 4px;">
                <option value="front">Front View</option>
                <option value="side">Side View</option>
                <option value="top">Top View</option>
                <option value="perspective">Perspective</option>
                <option value="close">Close Up</option>
                <option value="custom">Custom</option>
            </select>
            
            <label for="cameraX">Camera X: <span id="cameraXValue">0</span></label>
            <input type="range" id="cameraX" min="-20" max="20" step="0.5" value="0" style="width: 100%; margin: 5px 0;">
            
            <label for="cameraY">Camera Y: <span id="cameraYValue">0</span></label>
            <input type="range" id="cameraY" min="-20" max="20" step="0.5" value="0" style="width: 100%; margin: 5px 0;">
            
            <label for="cameraZ">Camera Z: <span id="cameraZValue">5</span></label>
            <input type="range" id="cameraZ" min="1" max="30" step="0.5" value="5" style="width: 100%; margin: 5px 0;">
            
            <label for="fov">Field of View: <span id="fovValue">75</span>°</label>
            <input type="range" id="fov" min="20" max="120" step="5" value="75" style="width: 100%; margin: 5px 0;">
        </div>
        
        <div class="section">
            <h3>Model Controls</h3>
            <label for="modelScale">Scale: <span id="modelScaleValue">1.0</span></label>
            <input type="range" id="modelScale" min="0.1" max="5.0" step="0.1" value="1.0" style="width: 100%; margin: 5px 0;">
            
            <label for="modelRotX">Rotation X: <span id="modelRotXValue">0</span>°</label>
            <input type="range" id="modelRotX" min="-180" max="180" step="1" value="0" style="width: 100%; margin: 5px 0;">
            
            <label for="modelRotY">Rotation Y: <span id="modelRotYValue">0</span>°</label>
            <input type="range" id="modelRotY" min="-180" max="180" step="1" value="0" style="width: 100%; margin: 5px 0;">
            
            <label for="modelRotZ">Rotation Z: <span id="modelRotZValue">0</span>°</label>
            <input type="range" id="modelRotZ" min="-180" max="180" step="1" value="0" style="width: 100%; margin: 5px 0;">
            
            <label for="modelX">Position X: <span id="modelXValue">0</span></label>
            <input type="range" id="modelX" min="-10" max="10" step="0.1" value="0" style="width: 100%; margin: 5px 0;">
            
            <label for="modelY">Position Y: <span id="modelYValue">0</span></label>
            <input type="range" id="modelY" min="-10" max="10" step="0.1" value="0" style="width: 100%; margin: 5px 0;">
            
            <label for="modelZ">Position Z: <span id="modelZValue">0</span></label>
            <input type="range" id="modelZ" min="-10" max="10" step="0.1" value="0" style="width: 100%; margin: 5px 0;">
        </div>
        
        <div class="section">
            <h3>Scene & Lighting</h3>
            <select id="backgroundPreset" style="width: 100%; padding: 10px; margin: 5px 0; background: #555; color: white; border: none; border-radius: 4px;">
                <option value="dark">Dark</option>
                <option value="light">Light</option>
                <option value="gradient">Gradient</option>
                <option value="studio">Studio</option>
            </select>
            
            <button onclick="toggleWireframe()">Toggle Wireframe</button>
            <button onclick="toggleLighting()">Toggle Lighting</button>
            <button onclick="saveScene()">Save Scene</button>
            <button onclick="loadScene()">Load Scene</button>
        </div>
        
        <div id="status">
            Status: Click Start Camera
        </div>
    </div>
    
    <div id="three-container"></div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

    <script>
        // Three.js variables
        let scene, camera3d, renderer, model, controls;
        let wireframeMode = false;
        let lightingEnabled = true;
        let ambientLight, directionalLight, spotLight;
        let modelPosition = { x: 0, y: 0, z: 0 };
        let cameraPosition = { x: 0, y: 0, z: 5 };
        let currentPreset = 'perspective';
        
        // Head tracking variables
        let cameraMediaPipe = null;
        let faceMesh = null;
        let calibrationCenter = { x: 0, y: 0 };
        let isCalibrated = false;
        let cameraOrbit = { theta: 0, phi: 0, radius: 5 };
        let modelRotation = { x: 0, y: 0, z: 0 };
        let sensitivityX = 60;
        let sensitivityY = 40;
        let offsetX = 0;
        let offsetY = 0;
        let sameSensitivity = false;
        let invertX = false;
        let invertY = false;
        let panelVisible = true;
        let lastUpdateTime = 0;

        // Initialize Three.js scene
        function initThreeJS() {
            const container = document.getElementById('three-container');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            
            // Camera
            camera3d = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera3d.position.set(0, 0, 5);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(renderer.domElement);
            
            // Lights
            ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            spotLight = new THREE.SpotLight(0xffffff, 0.5);
            spotLight.position.set(-10, 10, 10);
            spotLight.castShadow = true;
            scene.add(spotLight);
            
            // Controls
            controls = new THREE.OrbitControls(camera3d, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Create default cube
            createDefaultCube();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Start render loop
            animate();
        }

        function createDefaultCube() {
            if (model) {
                scene.remove(model);
                if (model.geometry) model.geometry.dispose();
                if (model.material) {
                    if (Array.isArray(model.material)) {
                        model.material.forEach(m => m.dispose());
                    } else {
                        model.material.dispose();
                    }
                }
            }
            
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const materials = [
                new THREE.MeshLambertMaterial({ color: 0xff0000 }), // Right
                new THREE.MeshLambertMaterial({ color: 0xff8c00 }), // Left
                new THREE.MeshLambertMaterial({ color: 0xffffff }), // Top
                new THREE.MeshLambertMaterial({ color: 0xeaff00 }), // Bottom
                new THREE.MeshLambertMaterial({ color: 0x00ff08 }), // Front
                new THREE.MeshLambertMaterial({ color: 0x1900ff })  // Back
            ];
            
            model = new THREE.Mesh(geometry, materials);
            model.castShadow = true;
            model.receiveShadow = true;
            scene.add(model);
            
            updateStatus('Default cube created');
        }

        function loadModel(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            updateStatus('Loading model...');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const loader = new THREE.GLTFLoader();
                loader.parse(e.target.result, '', function(gltf) {
                    if (model) {
                        scene.remove(model);
                    }
                    
                    model = gltf.scene;
                    model.traverse(function(child) {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    model.position.sub(center);
                    
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 2 / maxDim;
                    model.scale.setScalar(scale);
                    
                    scene.add(model);
                    updateStatus(`Model loaded: ${file.name}`);
                }, function(error) {
                    updateStatus('Error loading model');
                    console.error(error);
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function resetModel() {
            if (model) {
                model.rotation.set(0, 0, 0);
                model.position.set(0, 0, 0);
                updateStatus('Model reset');
            }
        }

        function toggleWireframe() {
            if (!model) return;
            
            wireframeMode = !wireframeMode;
            model.traverse(function(child) {
                if (child.isMesh) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.wireframe = wireframeMode);
                    } else {
                        child.material.wireframe = wireframeMode;
                    }
                }
            });
            updateStatus(`Wireframe: ${wireframeMode ? 'ON' : 'OFF'}`);
        }

        function toggleLighting() {
            lightingEnabled = !lightingEnabled;
            ambientLight.visible = lightingEnabled;
            directionalLight.visible = lightingEnabled;
            updateStatus(`Lighting: ${lightingEnabled ? 'ON' : 'OFF'}`);
        }

        function onWindowResize() {
            const container = document.getElementById('three-container');
            camera3d.aspect = container.clientWidth / container.clientHeight;
            camera3d.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (isCalibrated) {
                controls.enabled = false;
                const x = cameraOrbit.radius * Math.sin(cameraOrbit.phi) * Math.cos(cameraOrbit.theta);
                const y = cameraOrbit.radius * Math.cos(cameraOrbit.phi);
                const z = cameraOrbit.radius * Math.sin(cameraOrbit.phi) * Math.sin(cameraOrbit.theta);
                camera3d.position.set(x + modelPosition.x, y + modelPosition.y, z + modelPosition.z);
                camera3d.lookAt(modelPosition.x, modelPosition.y, modelPosition.z);
            } else {
                controls.enabled = true;
                controls.update();
            }
            
            if (model) {
                model.position.set(modelPosition.x, modelPosition.y, modelPosition.z);
                model.rotation.set(
                    modelRotation.x * Math.PI / 180,
                    modelRotation.y * Math.PI / 180,
                    modelRotation.z * Math.PI / 180
                );
            }
            
            renderer.render(scene, camera3d);
        }

        // Head tracking functions (adapted from original)
        async function startCamera() {
            try {
                const video = document.getElementById('video');
                
                faceMesh = new FaceMesh({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
                });
                
                faceMesh.setOptions({
                    maxNumFaces: 1,
                    refineLandmarks: true,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                faceMesh.onResults(onResults);
                
                cameraMediaPipe = new Camera(video, {
                    onFrame: async () => {
                        await faceMesh.send({ image: video });
                    },
                    width: 640,
                    height: 480
                });
                
                await cameraMediaPipe.start();
                updateStatus('Camera started - Press Space to calibrate');
                
            } catch (error) {
                console.error('Camera error:', error);
                updateStatus('Error starting camera: ' + error.message);
            }
        }

        function onResults(results) {
            console.log('onResults called, faces:', results.multiFaceLandmarks?.length || 0);
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                const noseTip = landmarks[1];
                console.log('Nose position:', noseTip.x, noseTip.y);
                
                updateHeadDot(noseTip.x, noseTip.y);
                
                if (isCalibrated) {
                    const currentTime = Date.now();
                    if (currentTime - lastUpdateTime > 16) {
                        console.log('Updating model rotation');
                        updateModelRotation(noseTip.x, noseTip.y);
                        lastUpdateTime = currentTime;
                    }
                    updateStatus('Tracking active');
                } else {
                    updateStatus('Face detected - Press Space to calibrate');
                }
            } else {
                document.getElementById('head-dot').style.display = 'none';
                updateStatus('No face detected');
            }
        }

        function updateModelRotation(x, y) {
            const deltaX = (x - calibrationCenter.x) * (invertX ? -1 : 1);
            const deltaY = (y - calibrationCenter.y) * (invertY ? -1 : 1);
            
            cameraOrbit.theta = (deltaX * sensitivityX * 0.05) + (offsetX * 0.05);
            cameraOrbit.phi = Math.PI / 2 + (deltaY * sensitivityY * 0.05) + (offsetY * 0.05);
            console.log('Camera orbit:', cameraOrbit);
        }

        function calibrate() {
            const dot = document.getElementById('head-dot');
            if (dot.style.display === 'block') {
                calibrationCenter.x = parseFloat(dot.style.left) / document.getElementById('video').offsetWidth;
                calibrationCenter.y = parseFloat(dot.style.top) / document.getElementById('video').offsetHeight;
                isCalibrated = true;
                saveSettings();
                updateStatus('Calibrated! Head tracking active');
            } else {
                updateStatus('No face detected - cannot calibrate');
            }
        }

        function updateHeadDot(x, y) {
            const dot = document.getElementById('head-dot');
            const video = document.getElementById('video');
            
            dot.style.left = (x * video.offsetWidth) + 'px';
            dot.style.top = (y * video.offsetHeight) + 'px';
            dot.style.display = 'block';
        }

        function updateStatus(message) {
            document.getElementById('status').textContent = 'Status: ' + message;
        }

        // UI Controls
        function setupControls() {
            // Sensitivity controls
            const sensitivityXSlider = document.getElementById('sensitivityX');
            const sensitivityYSlider = document.getElementById('sensitivityY');
            const offsetXSlider = document.getElementById('offsetX');
            const offsetYSlider = document.getElementById('offsetY');
            const modelScaleSlider = document.getElementById('modelScale');
            const cameraXSlider = document.getElementById('cameraX');
            const cameraYSlider = document.getElementById('cameraY');
            const cameraZSlider = document.getElementById('cameraZ');
            const fovSlider = document.getElementById('fov');
            const modelXSlider = document.getElementById('modelX');
            const modelYSlider = document.getElementById('modelY');
            const modelZSlider = document.getElementById('modelZ');
            const cameraPresetSelect = document.getElementById('cameraPreset');
            const backgroundPresetSelect = document.getElementById('backgroundPreset');
            
            sensitivityXSlider.oninput = function() {
                sensitivityX = parseInt(this.value);
                document.getElementById('sensitivityXValue').textContent = sensitivityX;
                if (sameSensitivity) {
                    sensitivityY = sensitivityX;
                    sensitivityYSlider.value = sensitivityX;
                    document.getElementById('sensitivityYValue').textContent = sensitivityX;
                }
                saveSettings();
            };
            
            sensitivityYSlider.oninput = function() {
                sensitivityY = parseInt(this.value);
                document.getElementById('sensitivityYValue').textContent = sensitivityY;
                saveSettings();
            };
            
            offsetXSlider.oninput = function() {
                offsetX = parseInt(this.value);
                document.getElementById('offsetXValue').textContent = offsetX;
                saveSettings();
            };
            
            offsetYSlider.oninput = function() {
                offsetY = parseInt(this.value);
                document.getElementById('offsetYValue').textContent = offsetY;
                saveSettings();
            };
            
            modelScaleSlider.oninput = function() {
                const scale = parseFloat(this.value);
                document.getElementById('modelScaleValue').textContent = scale.toFixed(1);
                if (model) {
                    model.scale.setScalar(scale);
                }
                saveSettings();
            };
            
            // Camera controls
            cameraXSlider.oninput = function() {
                cameraPosition.x = parseFloat(this.value);
                document.getElementById('cameraXValue').textContent = cameraPosition.x;
                saveSettings();
            };
            
            cameraYSlider.oninput = function() {
                cameraPosition.y = parseFloat(this.value);
                document.getElementById('cameraYValue').textContent = cameraPosition.y;
                saveSettings();
            };
            
            cameraZSlider.oninput = function() {
                const value = parseFloat(this.value);
                cameraOrbit.radius = value;
                cameraPosition.z = value;
                document.getElementById('cameraZValue').textContent = value;
                saveSettings();
            };
            
            fovSlider.oninput = function() {
                const fov = parseInt(this.value);
                document.getElementById('fovValue').textContent = fov;
                camera3d.fov = fov;
                camera3d.updateProjectionMatrix();
                saveSettings();
            };
            
            // Model position controls
            document.getElementById('modelRotX').oninput = function() {
                modelRotation.x = parseFloat(this.value);
                document.getElementById('modelRotXValue').textContent = modelRotation.x;
                saveSettings();
            };
            
            document.getElementById('modelRotY').oninput = function() {
                modelRotation.y = parseFloat(this.value);
                document.getElementById('modelRotYValue').textContent = modelRotation.y;
                saveSettings();
            };
            
            document.getElementById('modelRotZ').oninput = function() {
                modelRotation.z = parseFloat(this.value);
                document.getElementById('modelRotZValue').textContent = modelRotation.z;
                saveSettings();
            };
            
            modelXSlider.oninput = function() {
                modelPosition.x = parseFloat(this.value);
                document.getElementById('modelXValue').textContent = modelPosition.x;
                saveSettings();
            };
            
            modelYSlider.oninput = function() {
                modelPosition.y = parseFloat(this.value);
                document.getElementById('modelYValue').textContent = modelPosition.y;
                saveSettings();
            };
            
            modelZSlider.oninput = function() {
                modelPosition.z = parseFloat(this.value);
                document.getElementById('modelZValue').textContent = modelPosition.z;
                saveSettings();
            };
            
            // Presets
            cameraPresetSelect.onchange = function() {
                applyCameraPreset(this.value);
                saveSettings();
            };
            
            backgroundPresetSelect.onchange = function() {
                applyBackgroundPreset(this.value);
                saveSettings();
            };
            
            // Checkboxes
            document.getElementById('sameSensitivity').onchange = function() {
                sameSensitivity = this.checked;
                saveSettings();
            };
            
            document.getElementById('invertX').onchange = function() {
                invertX = this.checked;
                saveSettings();
            };
            
            document.getElementById('invertY').onchange = function() {
                invertY = this.checked;
                saveSettings();
            };
            
            // Panel toggle
            document.getElementById('toggle-panel').onclick = function() {
                const panel = document.getElementById('camera-panel');
                const button = this;
                
                panelVisible = !panelVisible;
                
                if (panelVisible) {
                    panel.classList.remove('hidden');
                    button.classList.remove('panel-hidden');
                    button.classList.add('panel-visible');
                    button.textContent = '◀';
                } else {
                    panel.classList.add('hidden');
                    button.classList.remove('panel-visible');
                    button.classList.add('panel-hidden');
                    button.textContent = '▶';
                }
                
                setTimeout(onWindowResize, 300);
            };
        }

        // Camera enumeration
        async function enumerateCameras() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                const select = document.getElementById('cameraSelect');
                
                select.innerHTML = '<option value="">Select Camera...</option>';
                
                videoDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Camera ${index + 1}`;
                    select.appendChild(option);
                });
                
                return videoDevices.length > 0 ? videoDevices[0].deviceId : null;
                
            } catch (error) {
                updateStatus('Error enumerating cameras: ' + error.message);
                return null;
            }
        }

        // Save/Load all settings
        function saveSettings() {
            const data = {
                calibrationCenter,
                isCalibrated,
                sensitivityX,
                sensitivityY,
                offsetX,
                offsetY,
                sameSensitivity,
                invertX,
                invertY,
                cameraPosition,
                modelPosition,
                modelRotation,
                cameraOrbit,
                fov: camera3d.fov,
                modelScale: model ? model.scale.x : 1,
                cameraPreset: currentPreset,
                background: scene.background.getHex(),
                wireframeMode,
                lightingEnabled
            };
            localStorage.setItem('scene3DSettings', JSON.stringify(data));
        }

        function loadSettings() {
            const saved = localStorage.getItem('scene3DSettings');
            if (!saved) return;
            
            const data = JSON.parse(saved);
            
            // Head tracking
            calibrationCenter = data.calibrationCenter || { x: 0, y: 0 };
            isCalibrated = data.isCalibrated || false;
            sensitivityX = data.sensitivityX || 60;
            sensitivityY = data.sensitivityY || 40;
            offsetX = data.offsetX || 0;
            offsetY = data.offsetY || 0;
            sameSensitivity = data.sameSensitivity || false;
            invertX = data.invertX || false;
            invertY = data.invertY || false;
            
            // Camera & Model
            if (data.cameraPosition) cameraPosition = data.cameraPosition;
            if (data.modelPosition) modelPosition = data.modelPosition;
            if (data.modelRotation) modelRotation = data.modelRotation;
            if (data.cameraOrbit) cameraOrbit = data.cameraOrbit;
            if (data.fov) camera3d.fov = data.fov;
            if (data.cameraPreset) currentPreset = data.cameraPreset;
            if (data.background) scene.background = new THREE.Color(data.background);
            if (data.wireframeMode !== undefined) wireframeMode = data.wireframeMode;
            if (data.lightingEnabled !== undefined) lightingEnabled = data.lightingEnabled;
            
            // Update UI
            document.getElementById('sensitivityX').value = sensitivityX;
            document.getElementById('sensitivityY').value = sensitivityY;
            document.getElementById('offsetX').value = offsetX;
            document.getElementById('offsetY').value = offsetY;
            document.getElementById('sensitivityXValue').textContent = sensitivityX;
            document.getElementById('sensitivityYValue').textContent = sensitivityY;
            document.getElementById('offsetXValue').textContent = offsetX;
            document.getElementById('offsetYValue').textContent = offsetY;
            document.getElementById('sameSensitivity').checked = sameSensitivity;
            document.getElementById('invertX').checked = invertX;
            document.getElementById('invertY').checked = invertY;
            
            document.getElementById('cameraX').value = cameraPosition.x;
            document.getElementById('cameraY').value = cameraPosition.y;
            document.getElementById('cameraZ').value = cameraPosition.z;
            document.getElementById('cameraXValue').textContent = cameraPosition.x;
            document.getElementById('cameraYValue').textContent = cameraPosition.y;
            document.getElementById('cameraZValue').textContent = cameraPosition.z;
            
            document.getElementById('modelX').value = modelPosition.x;
            document.getElementById('modelY').value = modelPosition.y;
            document.getElementById('modelZ').value = modelPosition.z;
            document.getElementById('modelXValue').textContent = modelPosition.x;
            document.getElementById('modelYValue').textContent = modelPosition.y;
            document.getElementById('modelZValue').textContent = modelPosition.z;
            
            document.getElementById('modelRotX').value = modelRotation.x;
            document.getElementById('modelRotY').value = modelRotation.y;
            document.getElementById('modelRotZ').value = modelRotation.z;
            document.getElementById('modelRotXValue').textContent = modelRotation.x;
            document.getElementById('modelRotYValue').textContent = modelRotation.y;
            document.getElementById('modelRotZValue').textContent = modelRotation.z;
            
            document.getElementById('fov').value = camera3d.fov;
            document.getElementById('fovValue').textContent = camera3d.fov;
            camera3d.updateProjectionMatrix();
            
            if (data.modelScale && model) {
                model.scale.setScalar(data.modelScale);
                document.getElementById('modelScale').value = data.modelScale;
                document.getElementById('modelScaleValue').textContent = data.modelScale.toFixed(1);
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.code === 'Space') {
                event.preventDefault();
                calibrate();
            }
        });

        // Camera and scene functions
        function updateCameraPosition() {
            camera3d.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);
            camera3d.lookAt(modelPosition.x, modelPosition.y, modelPosition.z);
        }
        
        function updateModelPosition() {
            if (model) {
                model.position.set(modelPosition.x, modelPosition.y, modelPosition.z);
                camera3d.lookAt(modelPosition.x, modelPosition.y, modelPosition.z);
            }
        }
        
        function applyCameraPreset(preset) {
            currentPreset = preset;
            
            switch(preset) {
                case 'front':
                    setCameraPosition(0, 0, 8);
                    break;
                case 'side':
                    setCameraPosition(8, 0, 0);
                    break;
                case 'top':
                    setCameraPosition(0, 8, 0);
                    break;
                case 'perspective':
                    setCameraPosition(5, 3, 5);
                    break;
                case 'close':
                    setCameraPosition(0, 0, 3);
                    break;
            }
        }
        
        function setCameraPosition(x, y, z) {
            cameraPosition = { x, y, z };
            document.getElementById('cameraX').value = x;
            document.getElementById('cameraY').value = y;
            document.getElementById('cameraZ').value = z;
            document.getElementById('cameraXValue').textContent = x;
            document.getElementById('cameraYValue').textContent = y;
            document.getElementById('cameraZValue').textContent = z;
            updateCameraPosition();
        }
        
        function applyBackgroundPreset(preset) {
            switch(preset) {
                case 'dark':
                    scene.background = new THREE.Color(0x222222);
                    break;
                case 'light':
                    scene.background = new THREE.Color(0xf0f0f0);
                    break;
                case 'gradient':
                    scene.background = new THREE.Color(0x87CEEB);
                    break;
                case 'studio':
                    scene.background = new THREE.Color(0x404040);
                    ambientLight.intensity = 0.8;
                    directionalLight.intensity = 1.0;
                    break;
            }
        }
        
        function saveScene() {
            const sceneData = {
                cameraPosition,
                modelPosition,
                fov: camera3d.fov,
                modelScale: model ? model.scale.x : 1,
                preset: currentPreset,
                background: scene.background.getHex()
            };
            
            const dataStr = JSON.stringify(sceneData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = 'scene_config.json';
            link.click();
            
            URL.revokeObjectURL(url);
            updateStatus('Scene saved!');
        }
        
        function loadScene() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const sceneData = JSON.parse(e.target.result);
                        
                        // Apply camera settings
                        if (sceneData.cameraPosition) {
                            setCameraPosition(
                                sceneData.cameraPosition.x,
                                sceneData.cameraPosition.y,
                                sceneData.cameraPosition.z
                            );
                        }
                        
                        // Apply model position
                        if (sceneData.modelPosition) {
                            modelPosition = sceneData.modelPosition;
                            document.getElementById('modelX').value = modelPosition.x;
                            document.getElementById('modelY').value = modelPosition.y;
                            document.getElementById('modelZ').value = modelPosition.z;
                            document.getElementById('modelXValue').textContent = modelPosition.x;
                            document.getElementById('modelYValue').textContent = modelPosition.y;
                            document.getElementById('modelZValue').textContent = modelPosition.z;
                            updateModelPosition();
                        }
                        
                        // Apply FOV
                        if (sceneData.fov) {
                            camera3d.fov = sceneData.fov;
                            camera3d.updateProjectionMatrix();
                            document.getElementById('fov').value = sceneData.fov;
                            document.getElementById('fovValue').textContent = sceneData.fov;
                        }
                        
                        // Apply model scale
                        if (sceneData.modelScale && model) {
                            model.scale.setScalar(sceneData.modelScale);
                            document.getElementById('modelScale').value = sceneData.modelScale;
                            document.getElementById('modelScaleValue').textContent = sceneData.modelScale.toFixed(1);
                        }
                        
                        // Apply background
                        if (sceneData.background) {
                            scene.background = new THREE.Color(sceneData.background);
                        }
                        
                        updateStatus('Scene loaded!');
                        
                    } catch (error) {
                        updateStatus('Error loading scene: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }
        
        // Initialize everything
        window.onload = function() {
            initThreeJS();
            setupControls();
            loadSettings();
            enumerateCameras();
            updateStatus('Ready - Select camera and load 3D model');
        };
    </script>
</body>
</html>
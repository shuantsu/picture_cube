<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cubo Mínimo - X, Y, U</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
    }

    #container {
      display: flex;
      height: 100vh;
    }

    #controls {
      width: 300px;
      padding: 20px;
      background: #f0f0f0;
    }

    #cube {
      flex: 1;
      display: grid;
      grid-template: repeat(3, 1fr) / repeat(4, 1fr);
      gap: 10px;
      padding: 20px;
    }

    .face {
      display: grid;
      grid-template: repeat(3, 1fr) / repeat(3, 1fr);
      gap: 2px;
      width: 120px;
      height: 120px;
    }

    .sticker {
      border: 1px solid #000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
    }

    .face-U {
      grid-area: 1 / 2;
    }

    .face-L {
      grid-area: 2 / 1;
    }

    .face-F {
      grid-area: 2 / 2;
    }

    .face-R {
      grid-area: 2 / 3;
    }

    .face-B {
      grid-area: 2 / 4;
    }

    .face-D {
      grid-area: 3 / 2;
    }

    button {
      margin: 5px;
      padding: 10px;
    }

    textarea {
      width: 100%;
      height: 100px;
      margin: 10px 0;
    }
  </style>
</head>

<body>
  <div id="container">
    <div id="controls">
      <h3>Fundamentos: X, Y, U, Z</h3>
      <button onclick="moveU()">U</button>
      <button onclick="rotationX()">X</button>
      <button onclick="rotationY()">Y</button>
      <button onclick="rotationZ()">Z</button>
      <br>
      <button onclick="prime(moveU)()">U'</button>
      <button onclick="prime(rotationX)()">X'</button>
      <button onclick="prime(rotationY)()">Y'</button>
      <button onclick="prime(rotationZ)()">Z'</button>
      <br>
      <button onclick="double(moveU)()">U2</button>
      <button onclick="double(rotationX)()">X2</button>
      <button onclick="double(rotationY)()">Y2</button>
      <button onclick="double(rotationZ)()">Z2</button>

      <h3>Derivados</h3>
      <button onclick="moveD()">D</button>
      <button onclick="moveR()">R</button>
      <button onclick="moveL()">L</button>
      <button onclick="moveF()">F</button>
      <button onclick="moveB()">B</button>
      <br>
      <button onclick="prime(moveD)()">D'</button>
      <button onclick="prime(moveR)()">R'</button>
      <button onclick="prime(moveL)()">L'</button>
      <button onclick="prime(moveF)()">F'</button>
      <button onclick="prime(moveB)()">B'</button>

      <h3>Algoritmo</h3>
      <textarea id="alg" placeholder="Digite algoritmo (ex: R U R' U')" onkeydown="if(event.ctrlKey && event.key==='Enter') applyAlgorithm()"></textarea>
      <button onclick="applyAlgorithm()">Executar</button>

      <h3>Estado</h3>
      <button onclick="solveCube()">Reset</button>
      <button onclick="printRotations()">Ver Rotações</button>
    </div>

    <div id="cube">
      <div class="face face-U" data-face="U"></div>
      <div class="face face-L" data-face="L"></div>
      <div class="face face-F" data-face="F"></div>
      <div class="face face-R" data-face="R"></div>
      <div class="face face-B" data-face="B"></div>
      <div class="face face-D" data-face="D"></div>
    </div>
  </div>

  <script>
    // ==================== FUNDAMENTOS: X, Y, U + applyStickerRotation ====================

    const faces = ['U', 'L', 'F', 'R', 'B', 'D'];
    const colors = ['white', 'orange', 'green', 'red', 'darkslateblue', 'yellow'];

    let cubeState = { U: [], L: [], F: [], R: [], B: [], D: [] };
    let stickerRotations = { U: [], L: [], F: [], R: [], B: [], D: [] };
    let stickerIds = { U: [], L: [], F: [], R: [], B: [], D: [] };

    function initCube() {
      faces.forEach((face, faceIndex) => {
        cubeState[face] = Array(9).fill(0).map((_, i) => faceIndex * 9 + i);
        stickerRotations[face] = Array(9).fill(0);
        stickerIds[face] = Array(9).fill(0).map((_, i) => faceIndex * 9 + i);

        const faceElement = document.querySelector(`[data-face="${face}"]`);
        faceElement.innerHTML = '';
        for (let i = 0; i < 9; i++) {
          const sticker = document.createElement('div');
          sticker.className = 'sticker';
          sticker.style.backgroundColor = colors[faceIndex];
          sticker.innerHTML = `<u>${faceIndex * 9 + i}</u>`;
          faceElement.appendChild(sticker);
        }
      });
    }

    function applyStickerRotation(face, index, rotationIncrement) {
      stickerRotations[face][index] = (stickerRotations[face][index] + rotationIncrement + 4) % 4;
    }

    // Detectar se sticker precisa de rotação 180° ao mudar de face
    function needsFlip(fromFace, toFace) {
      const faceB = 'B';
      const facesUDF = ['U', 'D', 'F'];
      return (fromFace === faceB && facesUDF.includes(toFace)) || 
             (facesUDF.includes(fromFace) && toFace === faceB);
    }

    function updateDOM() {
      faces.forEach((face, faceIndex) => {
        const faceElement = document.querySelector(`[data-face="${face}"]`);
        for (let i = 0; i < 9; i++) {
          const sticker = faceElement.children[i];
          const stickerId = cubeState[face][i];
          const colorIndex = Math.floor(stickerId / 9);
          sticker.style.backgroundColor = colors[colorIndex];
          sticker.innerHTML = `<u>${stickerId}</u>`;
          const rotation = stickerRotations[face][i] * 90;
          sticker.style.transform = rotation ? `rotate(${rotation}deg)` : '';
        }
      });
    }

    function rotateFaceDataCW(faceData) {
      return [faceData[6], faceData[3], faceData[0], faceData[7], faceData[4], faceData[1], faceData[8], faceData[5], faceData[2]];
    }

    function rotateFaceDataCCW(faceData) {
      return [faceData[2], faceData[5], faceData[8], faceData[1], faceData[4], faceData[7], faceData[0], faceData[3], faceData[6]];
    }

    function rotateFaceData180(faceData) {
      return [faceData[8], faceData[7], faceData[6], faceData[5], faceData[4], faceData[3], faceData[2], faceData[1], faceData[0]];
    }

    // MOVIMENTO U
    function moveU() {
      cubeState.U = rotateFaceDataCW(cubeState.U);
      stickerRotations.U = rotateFaceDataCW(stickerRotations.U);
      for (let i = 0; i < 9; i++) applyStickerRotation('U', i, 1);

      const temp = [cubeState.F[0], cubeState.F[1], cubeState.F[2]];
      const tempRot = [stickerRotations.F[0], stickerRotations.F[1], stickerRotations.F[2]];

      // F ← R (sem flip)
      cubeState.F[0] = cubeState.R[0]; cubeState.F[1] = cubeState.R[1]; cubeState.F[2] = cubeState.R[2];
      stickerRotations.F[0] = stickerRotations.R[0]; stickerRotations.F[1] = stickerRotations.R[1]; stickerRotations.F[2] = stickerRotations.R[2];

      // R ← B (sem flip - B para R não precisa)
      cubeState.R[0] = cubeState.B[0]; cubeState.R[1] = cubeState.B[1]; cubeState.R[2] = cubeState.B[2];
      stickerRotations.R[0] = stickerRotations.B[0]; stickerRotations.R[1] = stickerRotations.B[1]; stickerRotations.R[2] = stickerRotations.B[2];

      // B ← L (sem flip - L para B não precisa)
      cubeState.B[0] = cubeState.L[0]; cubeState.B[1] = cubeState.L[1]; cubeState.B[2] = cubeState.L[2];
      stickerRotations.B[0] = stickerRotations.L[0]; stickerRotations.B[1] = stickerRotations.L[1]; stickerRotations.B[2] = stickerRotations.L[2];

      // L ← F (sem flip)
      cubeState.L[0] = temp[0]; cubeState.L[1] = temp[1]; cubeState.L[2] = temp[2];
      stickerRotations.L[0] = tempRot[0]; stickerRotations.L[1] = tempRot[1]; stickerRotations.L[2] = tempRot[2];

      updateDOM();
    }

    // ROTAÇÃO X
    function rotationX() {
      const temp = cubeState.U;
      const tempRot = [...stickerRotations.U];

      cubeState.U = cubeState.F;
      stickerRotations.U = [...stickerRotations.F];

      cubeState.F = cubeState.D;
      stickerRotations.F = [...stickerRotations.D];

      cubeState.D = rotateFaceData180(cubeState.B);
      stickerRotations.D = rotateFaceData180(stickerRotations.B);
      for (let i = 0; i < 9; i++) applyStickerRotation('D', i, 2);

      cubeState.B = rotateFaceData180(temp);
      stickerRotations.B = rotateFaceData180(tempRot);
      for (let i = 0; i < 9; i++) applyStickerRotation('B', i, 2);

      cubeState.L = rotateFaceDataCCW(cubeState.L);
      stickerRotations.L = rotateFaceDataCCW(stickerRotations.L);
      for (let i = 0; i < 9; i++) applyStickerRotation('L', i, -1);

      cubeState.R = rotateFaceDataCW(cubeState.R);
      stickerRotations.R = rotateFaceDataCW(stickerRotations.R);
      for (let i = 0; i < 9; i++) applyStickerRotation('R', i, 1);

      updateDOM();
    }

    // ROTAÇÃO Y
    function rotationY() {
      const temp = cubeState.F;
      const tempRot = [...stickerRotations.F];

      cubeState.F = cubeState.R;
      stickerRotations.F = [...stickerRotations.R];

      cubeState.R = cubeState.B;
      stickerRotations.R = [...stickerRotations.B];

      cubeState.B = cubeState.L;
      stickerRotations.B = [...stickerRotations.L];

      cubeState.L = temp;
      stickerRotations.L = tempRot;

      cubeState.U = rotateFaceDataCW(cubeState.U);
      stickerRotations.U = rotateFaceDataCW(stickerRotations.U);
      for (let i = 0; i < 9; i++) applyStickerRotation('U', i, 1);

      cubeState.D = rotateFaceDataCCW(cubeState.D);
      stickerRotations.D = rotateFaceDataCCW(stickerRotations.D);
      for (let i = 0; i < 9; i++) applyStickerRotation('D', i, -1);

      updateDOM();
    }

    // CRIAR Z A PARTIR DE X E Y
    function rotationZ() { rotationY(); rotationX(); repeat(rotationY, 3); }

    // CONSTRUIR TODOS OS MOVIMENTOS A PARTIR DOS FUNDAMENTOS
    const repeat = (fn, times) => { for (let i = 0; i < times; i++) fn(); };
    const prime = (fn) => () => repeat(fn, 3);
    const double = (fn) => () => repeat(fn, 2);

    const moveD = () => { double(rotationX)(); moveU(); double(rotationX)(); };
    const moveR = () => { rotationZ(); moveU(); prime(rotationZ)(); };
    const moveL = () => { prime(rotationZ)(); moveU(); rotationZ(); };
    const moveF = () => { rotationX(); moveU(); prime(rotationX)(); };
    const moveB = () => { prime(rotationX)(); moveU(); rotationX(); };

    function applyMove(move) {
      const moves = {
        'U': moveU, 'D': moveD, 'R': moveR, 'L': moveL, 'F': moveF, 'B': moveB,
        'x': rotationX, 'y': rotationY, 'z': rotationZ,
        "U'": prime(moveU), "D'": prime(moveD), "R'": prime(moveR),
        "L'": prime(moveL), "F'": prime(moveF), "B'": prime(moveB),
        "x'": prime(rotationX), "y'": prime(rotationY), "z'": prime(rotationZ),
        'U2': double(moveU), 'D2': double(moveD), 'R2': double(moveR),
        'L2': double(moveL), 'F2': double(moveF), 'B2': double(moveB),
        'x2': double(rotationX), 'y2': double(rotationY), 'z2': double(rotationZ)
      };

      if (moves[move]) moves[move]();
    }

    function applyAlgorithm() {
      const alg = document.getElementById('alg').value.trim();
      if (!alg) return;
      const moves = alg.split(/\s+/);
      moves.forEach(move => applyMove(move));
    }

    function solveCube() {
      initCube();
    }

    function printRotations() {
      let total = 0;
      faces.forEach(face => {
        stickerRotations[face].forEach(rot => total += rot);
      });
      console.log('Total de rotações:', total);
      console.log('Rotações por face:', JSON.stringify(stickerRotations, null, 2));
    }

    // Inicializar
    initCube();
  </script>
</body>

</html>
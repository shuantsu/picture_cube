<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Move Graph — Cube Visualizer</title>
<style>
  :root{
    --bg:#0b1220; --panel:#0f1724; --muted:#9aa4b2; --accent:#6ee7b7;
    --node:#1b2430; --node-border:#2b3a4a; --node-active:#143f2e;
    --shadow: 0 6px 18px rgba(2,6,23,0.6);
    font-family: Inter, ui-sans-serif, system-ui, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071018 0%, #071827 100%);color:#e6eef6}
  .app{display:flex;gap:14px;height:100vh;padding:18px;box-sizing:border-box}
  .left{width:68%;background:linear-gradient(180deg,var(--panel),#071827);border-radius:10px;padding:16px;box-shadow:var(--shadow);display:flex;flex-direction:column}
  .right{width:32%;background:linear-gradient(180deg,#071827,var(--panel));border-radius:10px;padding:14px;box-shadow:var(--shadow);display:flex;flex-direction:column;gap:12px}
  h1{margin:0;font-size:16px;color:var(--accent)}
  .controls{display:flex;gap:8px;align-items:center;margin-top:8px}
  .controls input{flex:1;padding:8px;border-radius:8px;border:1px solid var(--node-border);background:transparent;color:inherit}
  .controls button{padding:8px 10px;border-radius:8px;border:0;background:linear-gradient(90deg,#0ea5a5,#6ee7b7);color:#042;cursor:pointer}
  .canvas{flex:1;position:relative;overflow:hidden;border-radius:8px;margin-top:12px;padding:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);min-height:300px}
  svg{width:100%;height:100%}
  .node {cursor:pointer;user-select:none}
  .node rect{fill:var(--node);stroke:var(--node-border);rx:8;ry:8}
  .node text{fill:var(--muted);font-size:12px;pointer-events:none}
  .node.selected rect{fill:var(--node-active);stroke:var(--accent)}
  .node .move{font-weight:600;fill:#eafaf1}
  .node.scramble rect{fill:#3d3a1a;stroke:#8b7355}
  .node.scramble .move{fill:#fbbf24}
  .node.scramble.selected rect{fill:#4a3d1f;stroke:var(--accent)}
  .side-panel h2{margin:0;font-size:14px;color:var(--accent)}
  .side-panel .box{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
  .btn{display:inline-block;padding:8px 10px;border-radius:8px;border:0;background:#1f6feb;color:white;cursor:pointer}
  .muted{color:var(--muted);font-size:13px}
  .small{font-size:13px}
  .moves-list{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}
  .chip{background:#0b1726;padding:6px 8px;border-radius:8px;border:1px solid #172433;color:var(--muted);font-weight:600}
  .footer{margin-top:auto;color:var(--muted);font-size:13px;text-align:center}
  .actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}

  .box button{padding:4px 6px;border-radius:4px;border:1px solid var(--node-border);background:var(--node);color:var(--muted);cursor:pointer;font-size:11px}
  .box button:hover{background:var(--node-active);color:white}
  .graph-indicator{position:absolute;width:50px;height:50px;background:var(--accent);border-radius:50%;display:flex;align-items:center;justify-content:center;cursor:pointer;z-index:10;opacity:0.9;box-shadow:0 4px 12px rgba(110,231,183,0.4);border:2px solid #042}
  .graph-indicator:hover{opacity:1;transform:scale(1.1);box-shadow:0 6px 16px rgba(110,231,183,0.6)}
  .graph-indicator::before{content:'→';color:#042;font-weight:900;font-size:24px}
  
  /* Custom Scrollbar */
  ::-webkit-scrollbar{width:8px}
  ::-webkit-scrollbar-track{background:var(--panel);border-radius:4px}
  ::-webkit-scrollbar-thumb{background:var(--node-border);border-radius:4px}
  ::-webkit-scrollbar-thumb:hover{background:var(--accent)}
  *{scrollbar-width:thin;scrollbar-color:var(--node-border) var(--panel)}
</style>
</head>
<body>
<div class="app">
  <div class="left">
    <h1>Move Graph — Visualizer</h1>
    <div class="controls">
      <input id="scrambleInput" placeholder="Scramble — e.g.: x R' U R' D2 R U' R' D2 R2 x'" />
      <button id="loadBtn">Load scramble</button>
      <button id="resetBtn" style="background:#ef4444;color:white">Reset</button>
    </div>

    <div class="canvas" id="canvas">
      <svg id="svgRoot" xmlns="http://www.w3.org/2000/svg"></svg>
      <div id="graphIndicator" class="graph-indicator" style="display:none"></div>
    </div>
  </div>

  <div class="right side-panel" style="overflow-y: auto;">

    <h2 style="margin-top:12px">Cube</h2>
    <div class="box">
      <script src="https://cdn.cubing.net/v0/js/cubing/twisty" type="module"></script>
      <twisty-player style="width:100%" background="none"  control-panel="none" alg=""></twisty-player>
    </div>

    <h2 style="margin-top:12px">Actions</h2>
    <div class="box">
      <div class="small muted">Create child (branch or continuation)</div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <input id="newMove" placeholder="e.g.: R' or U2" />
        <button class="btn" id="createChildBtn">Add</button>
      </div>
      

      
      <div class="small muted" style="margin-top:12px">Quick moves:</div>
      <div style="display:grid;grid-template-columns:repeat(6,1fr);gap:4px;margin-top:8px;font-size:12px">
        <button onclick="applyMove(`U`)">U</button>
        <button onclick="applyMove(`U'`)">U'</button>
        <button onclick="applyMove(`U2`)">U2</button>
        <button onclick="applyMove(`D`)">D</button>
        <button onclick="applyMove(`D'`)">D'</button>
        <button onclick="applyMove(`D2`)">D2</button>
        <button onclick="applyMove(`R`)">R</button>
        <button onclick="applyMove(`R'`)">R'</button>
        <button onclick="applyMove(`R2`)">R2</button>
        <button onclick="applyMove(`L`)">L</button>
        <button onclick="applyMove(`L'`)">L'</button>
        <button onclick="applyMove(`L2`)">L2</button>
        <button onclick="applyMove(`F`)">F</button>
        <button onclick="applyMove(`F'`)">F'</button>
        <button onclick="applyMove(`F2`)">F2</button>
        <button onclick="applyMove(`B`)">B</button>
        <button onclick="applyMove(`B'`)">B'</button>
        <button onclick="applyMove(`B2`)">B2</button>
        <button onclick="applyMove(`M`)">M</button>
        <button onclick="applyMove(`M'`)">M'</button>
        <button onclick="applyMove(`M2`)">M2</button>
        <button onclick="applyMove(`E`)">E</button>
        <button onclick="applyMove(`E'`)">E'</button>
        <button onclick="applyMove(`E2`)">E2</button>
        <button onclick="applyMove(`S`)">S</button>
        <button onclick="applyMove(`S'`)">S'</button>
        <button onclick="applyMove(`S2`)">S2</button>
        <button onclick="applyMove(`x`)">X</button>
        <button onclick="applyMove(`x'`)">X'</button>
        <button onclick="applyMove(`x2`)">X2</button>
        <button onclick="applyMove(`y`)">Y</button>
        <button onclick="applyMove(`y'`)">Y'</button>
        <button onclick="applyMove(`y2`)">Y2</button>
        <button onclick="applyMove(`z`)">Z</button>
        <button onclick="applyMove(`z'`)">Z'</button>
        <button onclick="applyMove(`z2`)">Z2</button>
        <button onclick="applyMove(`Rw`)">Rw</button>
        <button onclick="applyMove(`Rw'`)">Rw'</button>
        <button onclick="applyMove(`Rw2`)">Rw2</button>
        <button onclick="applyMove(`Lw`)">Lw</button>
        <button onclick="applyMove(`Lw'`)">Lw'</button>
        <button onclick="applyMove(`Lw2`)">Lw2</button>
        <button onclick="applyMove(`Uw`)">Uw</button>
        <button onclick="applyMove(`Uw'`)">Uw'</button>
        <button onclick="applyMove(`Uw2`)">Uw2</button>
        <button onclick="applyMove(`Dw`)">Dw</button>
        <button onclick="applyMove(`Dw'`)">Dw'</button>
        <button onclick="applyMove(`Dw2`)">Dw2</button>
        <button onclick="applyMove(`Fw`)">Fw</button>
        <button onclick="applyMove(`Fw'`)">Fw'</button>
        <button onclick="applyMove(`Fw2`)">Fw2</button>
        <button onclick="applyMove(`Bw`)">Bw</button>
        <button onclick="applyMove(`Bw'`)">Bw'</button>
        <button onclick="applyMove(`Bw2`)">Bw2</button>
      </div>

      <div class="actions" style="position: absolute;left:-9999px;top:-999px">
        <button id="exportPath" class="btn" style="background:#14b8a6">Export path</button>

        <button id="collapseAll" class="btn" style="background:#334155">Collapse visual</button>
      </div>
    </div>

    <h2>Current path</h2>
    <div class="box">
      <div id="pathBox" class="muted small">—</div>
      <div class="moves-list" id="movesChips"></div>
    </div>

<h2>Node information</h2>
    <div class="box">
      <div id="nodeInfo">
        <div class="muted">Click on a node on the left to see details</div>
      </div>
    </div>
  </div>
</div>

<script>
/* ===== utilidades ===== */
function uuid() {
  if (crypto && crypto.randomUUID) return crypto.randomUUID();
  return 'id-' + Math.random().toString(36).slice(2,9);
}

/* ===== modelo de nó ===== */
class MoveNode {
  constructor(move, parent = null, isScramble = false) {
    this.id = uuid();
    this.move = move; // string, "START" or move token
    this.parent = parent; // MoveNode | null
    this.children = []; // MoveNode[]
    this.isScramble = isScramble; // boolean
  }
}

/* ===== gerador de grafo a partir de lista linear ===== */
function createGraphFromList(moves, isScramble = false) {
  const root = new MoveNode("START", null);
  let cur = root;
  for (const mv of moves) {
    const n = new MoveNode(mv, cur, isScramble);
    cur.children.push(n);
    cur = n;
  }
  return root;
}

/* ===== layout: DFS com atribuição de linha/col =====
   - x = depthIndex * XSTEP
   - y = branchIndex * YSTEP
   - para o primeiro filho (assumido principal) mantemos a mesma linha
   - outros filhos recebem linhas novas (branchIndex incrementa)
*/
const XSTEP = 120, YSTEP = 72, NODE_W = 84, NODE_H = 36;
function layoutTree(root) {
  let branchCounter = 0;
  const positions = {}; // id -> {x,y,node}

  function dfs(node, depth, branchIndex, isFirstChild) {
    const x = depth * XSTEP;
    const y = branchIndex * YSTEP;
    positions[node.id] = {x,y,node};
    // children: first child keep same branch, others get new branches
    for (let i=0;i<node.children.length;i++) {
      const c = node.children[i];
      if (i===0) {
        dfs(c, depth+1, branchIndex, true);
      } else {
        branchCounter++;
        dfs(c, depth+1, branchCounter, false);
      }
    }
  }

  dfs(root, 0, 0, true);
  return positions;
}

/* ===== rendering SVG ===== */
const svg = document.getElementById('svgRoot');
let selectedNode = null;
let graphRoot = createGraphFromList([]); // inicial vazio

/* ===== pan e zoom ===== */
let transform = { x: 0, y: 0, scale: 1 };
let isPanning = false;
let lastPanPoint = { x: 0, y: 0 };

function applyTransform() {
  const g = svg.querySelector('#mainGroup') || document.createElementNS('http://www.w3.org/2000/svg', 'g');
  if (!g.id) {
    g.id = 'mainGroup';
    svg.appendChild(g);
  }
  g.setAttribute('transform', `translate(${transform.x}, ${transform.y}) scale(${transform.scale})`);
  return g;
}

function render() {
  const positions = layoutTree(graphRoot);

  // compute bounding box
  let maxX=0, maxY=0;
  for (const id in positions) {
    const p = positions[id];
    maxX = Math.max(maxX, p.x);
    maxY = Math.max(maxY, p.y);
  }
  svg.setAttribute('viewBox', `0 0 ${Math.max(800, maxX+300)} ${Math.max(400, maxY+200)}`);
  
  const mainGroup = applyTransform();
  mainGroup.innerHTML = '';
  
  // store bounds for minimap
  window.graphBounds = { maxX: maxX + NODE_W, maxY: maxY + NODE_H };

  // draw edges
  for (const id in positions) {
    const p = positions[id];
    for (const child of p.node.children) {
      const cpos = positions[child.id];
      if (!cpos) continue;
      const x1 = p.x + NODE_W, y1 = p.y + NODE_H/2;
      const x2 = cpos.x, y2 = cpos.y + NODE_H/2;
      // curve
      const midX = (x1 + x2) / 2;
      const path = document.createElementNS("http://www.w3.org/2000/svg","path");
      path.setAttribute('d', `M ${x1} ${y1} C ${midX} ${y1} ${midX} ${y2} ${x2} ${y2}`);
      path.setAttribute('stroke', 'rgba(255,255,255,0.06)');
      path.setAttribute('fill','none');
      path.setAttribute('stroke-width','2');
      mainGroup.appendChild(path);
    }
  }

  // draw nodes
  for (const id in positions) {
    const p = positions[id];
    const g = document.createElementNS("http://www.w3.org/2000/svg","g");
    g.setAttribute('class','node');
    g.setAttribute('transform', `translate(${p.x}, ${p.y})`);
    g.dataset.id = p.node.id;

    const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
    rect.setAttribute('width', NODE_W);
    rect.setAttribute('height', NODE_H);
    rect.setAttribute('rx', 8);
    rect.setAttribute('ry', 8);

    const txt = document.createElementNS("http://www.w3.org/2000/svg","text");
    txt.setAttribute('x', 12);
    txt.setAttribute('y', 22);
    txt.setAttribute('class','move');

    const label = p.node.move === "START" ? "START" : p.node.move;
    txt.textContent = label;

    g.appendChild(rect);
    g.appendChild(txt);

    // marker for selected
    if (selectedNode && selectedNode.id === p.node.id) {
      g.classList.add('selected');
    }
    
    // marker for scramble
    if (p.node.isScramble) {
      g.classList.add('scramble');
    }

    // click handling
    g.addEventListener('mousedown', (ev) => {
      if (!isPanning) {
        ev.stopPropagation();
        selectNodeById(p.node.id);
      }
    });

    // tooltip: number of children
    if (p.node.children.length > 1) {
      const badge = document.createElementNS("http://www.w3.org/2000/svg","text");
      badge.setAttribute('x', NODE_W - 10);
      badge.setAttribute('y', 20);
      badge.setAttribute('text-anchor','end');
      badge.setAttribute('fill','#9ad1c7');
      badge.setAttribute('font-size','11');
      badge.textContent = p.node.children.length;
      g.appendChild(badge);
    }

    mainGroup.appendChild(g);
  }
  
  updateGraphIndicator();
}

/* ===== indicador de grafo fora dos bounds ===== */
function updateGraphIndicator() {
  const indicator = document.getElementById('graphIndicator');
  const canvas = document.getElementById('canvas');
  const canvasRect = canvas.getBoundingClientRect();
  
  if (!window.graphBounds) {
    indicator.style.display = 'none';
    return;
  }
  
  // calculate graph center in screen coordinates
  const graphCenterX = (window.graphBounds.maxX / 2) * transform.scale + transform.x;
  const graphCenterY = (window.graphBounds.maxY / 2) * transform.scale + transform.y;
  
  // check if graph is visible
  const isVisible = graphCenterX >= 0 && graphCenterX <= canvasRect.width && 
                   graphCenterY >= 0 && graphCenterY <= canvasRect.height;
  
  if (isVisible) {
    indicator.style.display = 'none';
    return;
  }
  
  // calculate indicator position (closest edge)
  let indicatorX = Math.max(15, Math.min(canvasRect.width - 45, graphCenterX));
  let indicatorY = Math.max(15, Math.min(canvasRect.height - 45, graphCenterY));
  
  // calculate arrow rotation
  const dx = graphCenterX - indicatorX;
  const dy = graphCenterY - indicatorY;
  const angle = Math.atan2(dy, dx) * 180 / Math.PI;
  
  indicator.style.display = 'flex';
  indicator.style.left = indicatorX + 'px';
  indicator.style.top = indicatorY + 'px';
  indicator.style.transform = `rotate(${angle}deg)`;
  
  indicator.onclick = () => {
    transform.x = canvasRect.width / 2 - graphCenterX + transform.x;
    transform.y = canvasRect.height / 2 - graphCenterY + transform.y;
    applyTransform();
    updateGraphIndicator();
  };
}

/* ===== seleção e UI ===== */
const nodeInfo = document.getElementById('nodeInfo');
const pathBox = document.getElementById('pathBox');
const movesChips = document.getElementById('movesChips');
function selectNodeById(id) {
  const node = findNodeById(graphRoot, id);
  if (!node) return;
  selectedNode = node;
  updateInfoPanel(node);
  render();
}

function updateInfoPanel(node) {
  nodeInfo.innerHTML = '';
  const title = document.createElement('div');
  title.innerHTML = `<div style="font-weight:700">${node.move === 'START' ? 'START' : node.move}</div>`;
  const parentLabel = document.createElement('div');
  parentLabel.className = 'muted small';
  parentLabel.textContent = 'Parent: ' + (node.parent ? (node.parent.move) : '—');
  const childrenLabel = document.createElement('div');
  childrenLabel.className = 'muted small';
  childrenLabel.textContent = 'Children: ' + node.children.length;

  const path = getPathToNode(node);
  const pathText = path.filter(n=>n.move!=='START').map(n=>n.move).join('  ');

  const evBtn = document.createElement('button');
  evBtn.className = 'btn';
  evBtn.textContent = 'Select as current';
  evBtn.addEventListener('click', () => {
    document.getElementById('scrambleInput').value = pathText;
    document.getElementById('loadBtn').click();
    centerOnNode(node);
  });

  nodeInfo.appendChild(title);
  nodeInfo.appendChild(parentLabel);
  nodeInfo.appendChild(childrenLabel);
  nodeInfo.appendChild(document.createElement('hr'));
  const pdiv = document.createElement('div');
  pdiv.className = 'muted small';
  pdiv.textContent = 'Path to here:';
  nodeInfo.appendChild(pdiv);

  const pathPreview = document.createElement('div');
  pathPreview.className = 'box';
  pathPreview.style.marginTop = '8px';
  pathPreview.style.padding = '10px';
  pathPreview.textContent = pathText || '—';
  document.querySelector('twisty-player').setAttribute('alg', pathText);
  document.querySelector('twisty-player').jumpToEnd();
  nodeInfo.appendChild(pathPreview);

  nodeInfo.appendChild(evBtn);

  // update right panel path area
  pathBox.textContent = pathText || '—';
  movesChips.innerHTML = '';
  for (const n of path.filter(n=>n.move!=='START')) {
    const c = document.createElement('div');
    c.className = 'chip';
    c.textContent = n.move;
    movesChips.appendChild(c);
  }
}

/* center viewport on node */
function centerOnNode(node) {
  const positions = layoutTree(graphRoot);
  const p = positions[node.id];
  if (!p) return;
  
  const rect = svg.getBoundingClientRect();
  const centerX = rect.width / 2;
  const centerY = rect.height / 2;
  
  transform.x = centerX - (p.x + NODE_W/2) * transform.scale;
  transform.y = centerY - (p.y + NODE_H/2) * transform.scale;
  
  applyTransform();
}

/* find node by id */
function findNodeById(root, id) {
  let found = null;
  function dfs(n) {
    if (n.id === id) { found = n; return; }
    for (const c of n.children) {
      dfs(c);
      if (found) return;
    }
  }
  dfs(root);
  return found;
}

/* get path from root to node */
function getPathToNode(node) {
  const out = [];
  let cur = node;
  while (cur) {
    out.push(cur);
    cur = cur.parent;
  }
  return out.reverse();
}

/* create child for selected node (or root if none) */
function createChild(moveStr) {
  if (!moveStr || !moveStr.trim()) return;
  const base = selectedNode || graphRoot;
  const n = new MoveNode(moveStr.trim(), base);
  base.children.push(n);
  selectNodeById(n.id);
  render();
}



/* utility: reset graph */
function resetGraph() {
  graphRoot = createGraphFromList([]);
  selectedNode = graphRoot;
  render();
  nodeInfo.innerHTML = '<div class="muted">Click on a node on the left to see details</div>';
  pathBox.textContent = '—';
  movesChips.innerHTML = '';
}

/* collapse visual: fit to bounds */
function collapseVisual() {
  document.getElementById('minimap').dispatchEvent(new Event('dblclick'));
}

/* ===== função applyMove ===== */
function applyMove(moveStr) {
  document.getElementById('newMove').value = moveStr;
  createChild(moveStr);
  document.getElementById('newMove').value = '';
}

/* ===== UI wiring ===== */
document.getElementById('createChildBtn').addEventListener('click', () => {
  const mv = document.getElementById('newMove').value;
  if (!mv) return alert('Enter a move (e.g.: R, U2, F\')');
  
  const tokens = mv.trim().split(/\s+/).filter(Boolean);
  let current = selectedNode || graphRoot;
  
  for (const token of tokens) {
    const n = new MoveNode(token, current);
    current.children.push(n);
    current = n;
  }
  
  selectNodeById(current.id);
  render();
  document.getElementById('newMove').value = '';
});

document.getElementById('loadBtn').addEventListener('click', () => {
  const txt = document.getElementById('scrambleInput').value;
  const tokens = txt.trim().split(/\s+/).filter(Boolean);
  if (tokens.length === 0) { alert('Enter a scramble.'); return; }
  graphRoot = createGraphFromList(tokens, true);
  
  // Encontrar o nó final (último da sequência)
  let finalNode = graphRoot;
  while (finalNode.children.length > 0) {
    finalNode = finalNode.children[0];
  }
  
  selectedNode = finalNode;
  render();
  updateInfoPanel(finalNode);
});

document.getElementById('resetBtn').addEventListener('click', () => {
  if (!confirm('Reset graph?')) return;
  resetGraph();
});

document.getElementById('exportBtn')?.addEventListener('click', ()=>{ /* legacy */ });

document.getElementById('exportPath').addEventListener('click', () => {
  if (!selectedNode) return alert('Select a node.');
  const path = getPathToNode(selectedNode).filter(n=>n.move!=='START').map(n=>n.move).join(' ');
  navigator.clipboard?.writeText(path).then(()=> {
    alert('Path copied to clipboard:\n' + path);
  }, ()=> alert('Path:\n' + path));
});



document.getElementById('collapseAll').addEventListener('click', () => collapseVisual());

/* ===== pan e zoom events ===== */
svg.addEventListener('mousedown', (e) => {
  if (e.button === 0) { // botão esquerdo
    isPanning = true;
    lastPanPoint = { x: e.clientX, y: e.clientY };
    svg.style.cursor = 'grabbing';
    e.preventDefault();
  }
});

document.addEventListener('mousemove', (e) => {
  if (isPanning) {
    const dx = (e.clientX - lastPanPoint.x) * 1.2; // 1.2x mais rápido
    const dy = (e.clientY - lastPanPoint.y) * 1.2;
    transform.x += dx;
    transform.y += dy;
    lastPanPoint = { x: e.clientX, y: e.clientY };
    applyTransform();
    updateGraphIndicator();
  }
});

document.addEventListener('mouseup', () => {
  isPanning = false;
  svg.style.cursor = 'default';
});

svg.addEventListener('wheel', (e) => {
  e.preventDefault();
  const rect = svg.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
  const newScale = Math.max(0.1, Math.min(3, transform.scale * scaleFactor));
  
  // Zoom para o ponto do mouse
  const scaleChange = newScale / transform.scale;
  transform.x = mouseX - (mouseX - transform.x) * scaleChange;
  transform.y = mouseY - (mouseY - transform.y) * scaleChange;
  transform.scale = newScale;
  
  applyTransform();
  updateGraphIndicator();
});



/* initial demo content */
resetGraph();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Texture Creator - Picture Cube</title>

    <style>
        * { 
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }
        
        input, textarea {
            user-select: text;
            -webkit-user-select: text;
        }
        
        body { 
            margin: 0; 
            font-family: Arial, sans-serif; 
            background: #f5f5f5;
            display: flex;
            height: 100vh;
        }

        /* Left Panel - Texture Library */
        #texture-panel {
		padding-top: 25px;
            width: 300px;
            background: white;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
        }

        #texture-header {
            padding: 20px;
            border-bottom: 1px solid #ddd;
            background: #f8f9fa;
        }

        #texture-library {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .texture-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background: #f8f9fa;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid transparent;
            gap: 10px;
        }

        .texture-item:hover {
            border-color: #007cba;
        }

        .texture-item.selected {
            border-color: #28a745;
            background: #e8f5e8;
        }

        .texture-preview {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            border: 1px solid #ddd;
            flex-shrink: 0;
        }

        .texture-name {
            font-weight: 500;
            flex: 1;
        }

        .texture-edit {
            background: #007cba;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }

        .texture-edit:hover {
            background: #005a8b;
        }

        .texture-delete {
            background: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }

        .texture-delete:hover {
            background: #c82333;
        }

        /* Center Panel - Cube */
        #cube-panel {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
        }

        #cube-panel:active {
            cursor: grabbing;
        }

        #cube-wrapper {
            transform-origin: center;
            transition: transform 0.1s ease-out;
        }

        #cube-container {
            display: grid;
            grid-template-columns: repeat(4, 80px);
            grid-template-rows: repeat(3, 80px);
            gap: 4px;
            padding: 30px;
        }

        .face-wrapper {
            position: relative;
        }

        .cube-face {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            background: #333;
            padding: 2px;
            border-radius: 4px;
            border: 3px solid transparent;
            width: 80px;
            height: 80px;
        }

        .mode-face .cube-face:hover {
            border-color: #007cba;
        }

        .cube-sticker {
            background: #888;
            border: 1px solid #333;
            position: relative;
            border-radius: 2px;
        }

        .mode-sticker .cube-sticker {
            cursor: pointer;
        }

        .mode-sticker .cube-sticker:hover {
            box-shadow: 0 0 0 2px #007cba;
        }

        .mode-face .cube-sticker {
            pointer-events: none;
        }

        .mode-face .cube-face {
            cursor: pointer;
        }

        .mode-sticker .cube-face {
            cursor: default;
        }

        .face-wrapper.face-U { grid-column: 2; grid-row: 1; }
        .face-wrapper.face-L { grid-column: 1; grid-row: 2; }
        .face-wrapper.face-F { grid-column: 2; grid-row: 2; }
        .face-wrapper.face-R { grid-column: 3; grid-row: 2; }
        .face-wrapper.face-B { grid-column: 4; grid-row: 2; }
        .face-wrapper.face-D { grid-column: 2; grid-row: 3; }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
        }

        .modal-content h3 {
            margin: 0 0 20px 0;
        }

        .modal-content input,
        .modal-content textarea {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
        }

        .modal-content textarea {
            min-height: 100px;
            font-family: monospace;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        /* Right Panel - Controls */
        #control-panel {
            width: 300px;
            background: white;
            border-left: 1px solid #ddd;
            padding: 20px;
            overflow-y: auto;
        }

        .control-section {
            margin-bottom: 30px;
        }

        .control-section h3 {
            margin: 0 0 15px 0;
            color: #333;
        }

        button {
            background: #007cba;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px 5px 5px 0;
        }

        button:hover {
            background: #005a8b;
        }

        button.secondary {
            background: #6c757d;
        }

        input[type="file"] {
            margin: 10px 0;
        }

        input[type="text"], input[type="color"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin: 5px 0;
        }

        textarea {
            width: 100%;
            height: 200px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
        }

        #json-output, #import-json {
            background: #1e1e1e;
            color: #d4d4d4;
            tab-size: 2;
        }

        .texture-form {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }

        #toast {
            position: fixed;
            top: 30px;
            right: 30px;
            background: #333;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
            z-index: 2000;
            pointer-events: none;
        }

        #toast.show {
            opacity: 1;
            transform: translateY(0);
        }



        #confirm-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        #confirm-modal.active {
            display: flex;
        }

        #confirm-modal .modal-content {
            background: white;
            padding: 25px;
            border-radius: 8px;
            max-width: 400px;
            text-align: center;
        }

        #confirm-modal .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }



    </style>
</head>
<body>
    <!-- Texture Library Panel -->
    <div id="texture-panel">
        <div id="texture-header">
            <h2>Texture Library</h2>
            <div style="margin: 10px 0;">
                <label><input type="radio" name="mode" value="face" checked onchange="setMode(this.value)"> Whole Face</label>
                <label><input type="radio" name="mode" value="sticker" onchange="setMode(this.value)"> Individual Sticker</label>
            </div>
            <div id="selected-texture" style="margin: 10px 0; font-weight: bold; color: #666;">No texture selected</div>
            <div style="display: flex; gap: 5px; margin-top: 10px;">
                <input type="color" id="quick-color" value="#ff0000" style="width: 50px; height: 36px; cursor: pointer;">
                <button onclick="addQuickColor()" style="flex: 1;">Add Color</button>
            </div>
            <button onclick="document.getElementById('image-upload').click()" style="width: 100%; margin-top: 5px;">Upload Image</button>
            <button onclick="addCSSTexture()" style="width: 100%; margin-top: 5px;">+ CSS/SVG</button>
        </div>
        <div id="texture-library">
            <!-- Textures will be added here -->
        </div>
    </div>

    <!-- Cube Panel -->
    <div id="cube-panel">
        <div id="cube-wrapper">
            <div id="cube-container">
            <div class="face-wrapper face-U">
                <div class="cube-face" data-face="U"></div>
            </div>
            <div class="face-wrapper face-L">
                <div class="cube-face" data-face="L"></div>
            </div>
            <div class="face-wrapper face-F">
                <div class="cube-face" data-face="F"></div>
            </div>
            <div class="face-wrapper face-R">
                <div class="cube-face" data-face="R"></div>
            </div>
            <div class="face-wrapper face-B">
                <div class="cube-face" data-face="B"></div>
            </div>
            <div class="face-wrapper face-D">
                <div class="cube-face" data-face="D"></div>
            </div>
            </div>
        </div>
    </div>

    <!-- Control Panel -->
    <div id="control-panel">
        <input type="file" id="image-upload" accept="image/*" style="display: none;">

    <!-- Modal -->
    <div id="css-modal" class="modal">
        <div class="modal-content">
            <h3>Add Custom Texture</h3>
            <input type="text" id="modal-name" placeholder="Texture name">
            
            <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin: 10px 0;">
                <strong>Gradient Builder</strong>
                <div style="display: flex; gap: 5px; margin-top: 10px;">
                    <select id="grad-type" style="flex: 1;">
                        <option value="linear">Linear</option>
                        <option value="radial">Radial</option>
                        <option value="conic">Conic</option>
                    </select>
                    <input type="number" id="grad-angle" placeholder="Angle" value="45" style="width: 70px;">
                    <span style="line-height: 36px;">deg</span>
                </div>
                <div style="display: flex; gap: 5px; margin-top: 5px;">
                    <input type="color" id="grad-color1" value="#ff0000" style="width: 50px; height: 36px;">
                    <input type="color" id="grad-color2" value="#0000ff" style="width: 50px; height: 36px;">
                    <button onclick="applyGradient()" style="flex: 1;">Apply Gradient</button>
                </div>
                <div id="grad-preview" style="height: 40px; margin-top: 10px; border-radius: 4px; border: 1px solid #ddd;"></div>
            </div>
            
            <textarea id="modal-background" placeholder="Texture value:
linear-gradient(45deg, red, blue)
url('...')
$varName" rows="2"></textarea>
            <label style="display: block; margin: 10px 0;">
                <input type="checkbox" id="is-stackable"> Is stackable (uses array notation)
            </label>
            <div class="modal-buttons">
                <button onclick="saveCSSTexture()" style="flex: 1;">Add</button>
                <button onclick="closeModal()" class="secondary" style="flex: 1;">Cancel</button>
            </div>
        </div>
    </div>

        <div class="control-section">
            <h3>Variables</h3>
            <div id="vars-list" style="margin: 10px 0;"></div>
            <button onclick="addVar()" style="width: 100%;">+ Add Variable</button>
        </div>

        <div class="control-section">
            <h3>Actions</h3>
            <button onclick="clearCube()">Clear Cube</button>
            <button onclick="resetAll()" style="background: #dc3545;">Reset</button>
            <button onclick="exportConfig()" class="secondary">Export JSON</button>
            <button onclick="openImportModal()" class="secondary">Import JSON</button>
            <button onclick="triggerImportFromParent()" style="background: #28a745;">Reload JSON</button>
        </div>

        <div class="control-section">
            <h3>Generated JSON</h3>
            <textarea id="json-output" readonly spellcheck="false"></textarea>
        </div>
    </div>

    <div id="toast"></div>


    <button id="close-editor-btn" onclick="closeEditorModal()" style="display:none; position:fixed; bottom:20px; right:20px; background:#dc3545; z-index:1000;">✕ Close Editor</button>

    <div id="confirm-modal">
        <div class="modal-content">
            <h3 id="confirm-title">Clear Cube Assignments?</h3>
            <p id="confirm-message">This will remove all texture assignments from the cube.</p>
            <div class="modal-buttons">
                <button id="confirm-btn" onclick="confirmAction()" style="flex: 1; background: #dc3545;">Clear Cube</button>
                <button onclick="closeConfirmModal()" class="secondary" style="flex: 1;">Cancel</button>
            </div>
        </div>
    </div>

    <div id="import-modal" class="modal">
        <div class="modal-content">
            <h3>Import JSON Configuration</h3>
            <textarea id="import-json" placeholder="Paste your JSON configuration here..." style="min-height: 200px; font-family: monospace;"></textarea>
            <div class="modal-buttons">
                <button onclick="loadFromJSON()" style="flex: 1;">Load</button>
                <button onclick="closeImportModal()" class="secondary" style="flex: 1;">Cancel</button>
            </div>
        </div>
    </div>

    <div id="var-modal" class="modal">
        <div class="modal-content">
            <h3>Add Variable</h3>
            <input type="text" id="var-name" placeholder="Variable name (e.g., url, color1)">
            <input type="text" id="var-value" placeholder="Variable value">
            <div class="modal-buttons">
                <button onclick="saveVar()" style="flex: 1;">Add</button>
                <button onclick="closeVarModal()" class="secondary" style="flex: 1;">Cancel</button>
            </div>
        </div>
    </div>



    <script>
        // Toast notification
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // Confirm modal
        let confirmCallback = null;

        function showConfirmModal(title, message, buttonText, callback) {
            document.getElementById('confirm-title').textContent = title;
            document.getElementById('confirm-message').textContent = message;
            document.getElementById('confirm-btn').textContent = buttonText;
            confirmCallback = callback;
            document.getElementById('confirm-modal').classList.add('active');
        }

        function closeConfirmModal() {
            document.getElementById('confirm-modal').classList.remove('active');
            confirmCallback = null;
        }

        function confirmAction() {
            if (confirmCallback) confirmCallback();
            closeConfirmModal();
        }

        function clearCube() {
            showConfirmModal(
                'Clear Cube Assignments?',
                'This will remove all texture assignments from the cube.',
                'Clear Cube',
                () => {
                    cubeAssignments = {};
                    updateVisualCube();
                    updateJSON();
                    showToast('Cube assignments cleared');
                }
            );
        }

        function resetAll() {
            showConfirmModal(
                'Reset Everything?',
                'This will delete all textures, variables, and cube assignments. This cannot be undone.',
                'Reset',
                () => {
                    varsLibrary = {};
                    textureLibrary = {};
                    originalTextures = {};
                    textureUsesVars = {};
                    cubeAssignments = {};
                    selectedTexture = null;
                    initDefaultTextures();
                    updateVarsList();
                    updateVisualCube();
                    document.getElementById('selected-texture').textContent = 'No texture selected';
                    showToast('Everything reset');
                }
            );
        }

        // Global state
        let varsLibrary = {};
        let textureLibrary = {}; // Pure texture values (strings)
        let originalTextures = {}; // Original textures with variables
        let textureUsesVars = {}; // Track which textures use vars
        let textureStackable = {}; // Track which textures are stackable
        let cubeAssignments = {}; // Maps cube positions to texture names or arrays
        let selectedTexture = null;
        let currentMode = 'face';
        let scale = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let startX = 0;
        let startY = 0;

        // Initialize default textures
        function initDefaultTextures() {
            textureLibrary = {
                'red': '#c41e3a',
                'white': '#ffffff',
                'blue': '#0045ad',
                'green': '#009b48',
                'orange': '#ff5800',
                'yellow': '#ffd500'
            };
            updateTextureLibrary();
            updateJSON();
        }

        // Set mode
        function setMode(mode) {
            currentMode = mode;
            document.body.className = 'mode-' + mode;
        }

        // Create cube stickers
        function initCube() {
            const faces = ['U', 'L', 'F', 'R', 'B', 'D'];
            faces.forEach(face => {
                const faceEl = document.querySelector(`[data-face="${face}"]`);
                for (let i = 0; i < 9; i++) {
                    const sticker = document.createElement('div');
                    sticker.className = 'cube-sticker';
                    sticker.dataset.face = face;
                    sticker.dataset.sticker = i;
                    faceEl.appendChild(sticker);
                }
                
                faceEl.addEventListener('click', (e) => {
                    if (currentMode === 'sticker' && e.target.classList.contains('cube-sticker')) {
                        const stickerIndex = parseInt(e.target.dataset.sticker);
                        assignTexture(face, stickerIndex);
                    } else if (currentMode === 'face') {
                        assignTexture(face);
                    }
                });
            });
        }

        // Update texture library display
        function updateTextureLibrary() {
            const library = document.getElementById('texture-library');
            library.innerHTML = '';
            
            Object.entries(textureLibrary).forEach(([name, value]) => {
                const item = document.createElement('div');
                item.className = 'texture-item';
                if (selectedTexture === name) item.classList.add('selected');
                item.onclick = () => selectTexture(name);
                
                const preview = document.createElement('div');
                preview.className = 'texture-preview';
                if (value.startsWith('#')) {
                    preview.style.backgroundColor = value;
                } else {
                    preview.style.backgroundImage = value;
                    preview.style.backgroundSize = 'cover';
                }
                
                const nameEl = document.createElement('div');
                nameEl.className = 'texture-name';
                nameEl.textContent = name;
                
                const editBtn = document.createElement('button');
                editBtn.className = 'texture-edit';
                editBtn.textContent = 'Edit';
                editBtn.onclick = (e) => {
                    e.stopPropagation();
                    editTexture(name);
                };
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'texture-delete';
                deleteBtn.textContent = '×';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteTexture(name);
                };
                
                item.appendChild(preview);
                item.appendChild(nameEl);
                item.appendChild(editBtn);
                item.appendChild(deleteBtn);
                library.appendChild(item);
            });
        }

        // Select texture
        function selectTexture(name) {
            selectedTexture = name;
            updateTextureLibrary();
            document.getElementById('selected-texture').textContent = `Selected: ${name}`;
        }

        // Assign texture to face/sticker
        function assignTexture(face, sticker = null) {
            if (!selectedTexture) {
                showToast('Please select a texture first');
                return;
            }
            
            const key = sticker !== null ? `${face}${sticker}` : face;
            const faceKey = face;
            
            // Check if assigning to individual sticker
            if (sticker !== null) {
                const hasFaceTexture = cubeAssignments[faceKey];
                const currentSticker = cubeAssignments[key];
                
                if (!currentSticker && hasFaceTexture) {
                    // Sticker has no assignment but face does → use inherit mode [texture]
                    // Unless it's a solid color or var, then just replace
                    const texValue = textureLibrary[selectedTexture];
                    const isColorOrVar = texValue?.startsWith('#') || varsLibrary[selectedTexture];
                    cubeAssignments[key] = isColorOrVar ? selectedTexture : [selectedTexture];
                } else if (currentSticker) {
                    // Simple logic: if stackable, add to array; if not, replace
                    const isStackable = textureStackable[selectedTexture];
                    if (isStackable) {
                        if (Array.isArray(currentSticker)) {
                            cubeAssignments[key].push(selectedTexture);
                        } else {
                            cubeAssignments[key] = [currentSticker, selectedTexture];
                        }
                    } else {
                        cubeAssignments[key] = selectedTexture;
                    }
                } else {
                    // No face texture, no sticker texture → simple replace or array if stackable
                    const isStackable = textureStackable[selectedTexture];
                    cubeAssignments[key] = isStackable ? [selectedTexture] : selectedTexture;
                }
            } else {
                // Assigning to whole face - remove individual sticker assignments
                for (let i = 0; i < 9; i++) {
                    delete cubeAssignments[`${face}${i}`];
                }
                const isStackable = textureStackable[selectedTexture];
                cubeAssignments[face] = isStackable ? [selectedTexture] : selectedTexture;
            }
            
            updateVisualCube();
            updateJSON();
        }

        // Apply texture(s) to DOM element
        function applyTextureToElement(element, textureNameOrArray, isWholeFace = false) {
            const textures = Array.isArray(textureNameOrArray) ? textureNameOrArray : [textureNameOrArray];
            
            // Build background layers
            const bgImages = [];
            const bgSizes = [];
            const bgPositions = [];
            let hasColor = false;
            
            textures.forEach(textureName => {
                const value = textureLibrary[textureName];
                if (value.startsWith('#')) {
                    element.style.backgroundColor = value;
                    hasColor = true;
                } else {
                    bgImages.push(value);
                    bgSizes.push(isWholeFace ? '300% 300%' : 'cover');
                    
                    if (isWholeFace) {
                        const sticker = parseInt(element.dataset.sticker);
                        const row = Math.floor(sticker / 3);
                        const col = sticker % 3;
                        bgPositions.push(`${col * 50}% ${row * 50}%`);
                    } else {
                        bgPositions.push('center');
                    }
                }
            });
            
            if (bgImages.length > 0) {
                // Reverse arrays so first texture is bottom layer (CSS stacks first item on top)
                element.style.backgroundImage = bgImages.reverse().join(', ');
                element.style.backgroundSize = bgSizes.reverse().join(', ');
                element.style.backgroundPosition = bgPositions.reverse().join(', ');
                element.style.backgroundRepeat = 'no-repeat';
            } else if (!hasColor) {
                element.style.backgroundImage = 'none';
            }
        }

        // Get closest color name from 140 HTML colors
        function getColorName(hex) {
            const colors = {
                'CD5C5C':'indianred','F08080':'lightcoral','FA8072':'salmon','E9967A':'darksalmon','FFA07A':'lightsalmon',
                'DC143C':'crimson','FF0000':'red','B22222':'firebrick','8B0000':'darkred','FFC0CB':'pink',
                'FFB6C1':'lightpink','FF69B4':'hotpink','FF1493':'deeppink','C71585':'mediumvioletred','DB7093':'palevioletred',
                'FF7F50':'coral','FF6347':'tomato','FF4500':'orangered','FF8C00':'darkorange','FFA500':'orange',
                'FFD700':'gold','FFFF00':'yellow','FFFFE0':'lightyellow','FFFACD':'lemonchiffon','FAFAD2':'lightgoldenrodyellow',
                'FFEFD5':'papayawhip','FFE4B5':'moccasin','FFDAB9':'peachpuff','EEE8AA':'palegoldenrod','F0E68C':'khaki',
                'BDB76B':'darkkhaki','E6E6FA':'lavender','D8BFD8':'thistle','DDA0DD':'plum','EE82EE':'violet',
                'DA70D6':'orchid','FF00FF':'magenta','BA55D3':'mediumorchid','9370DB':'mediumpurple','663399':'rebeccapurple',
                '8A2BE2':'blueviolet','9400D3':'darkviolet','9932CC':'darkorchid','8B008B':'darkmagenta','800080':'purple',
                '4B0082':'indigo','6A5ACD':'slateblue','483D8B':'darkslateblue','7B68EE':'mediumslateblue','ADFF2F':'greenyellow',
                '7FFF00':'chartreuse','7CFC00':'lawngreen','00FF00':'lime','32CD32':'limegreen','98FB98':'palegreen',
                '90EE90':'lightgreen','00FA9A':'mediumspringgreen','00FF7F':'springgreen','3CB371':'mediumseagreen','2E8B57':'seagreen',
                '228B22':'forestgreen','008000':'green','006400':'darkgreen','9ACD32':'yellowgreen','6B8E23':'olivedrab',
                '808000':'olive','556B2F':'darkolivegreen','66CDAA':'mediumaquamarine','8FBC8B':'darkseagreen','20B2AA':'lightseagreen',
                '008B8B':'darkcyan','008080':'teal','00FFFF':'cyan','E0FFFF':'lightcyan','AFEEEE':'paleturquoise',
                '7FFFD4':'aquamarine','40E0D0':'turquoise','48D1CC':'mediumturquoise','00CED1':'darkturquoise','5F9EA0':'cadetblue',
                '4682B4':'steelblue','B0C4DE':'lightsteelblue','B0E0E6':'powderblue','ADD8E6':'lightblue','87CEEB':'skyblue',
                '87CEFA':'lightskyblue','00BFFF':'deepskyblue','1E90FF':'dodgerblue','6495ED':'cornflowerblue','4169E1':'royalblue',
                '0000FF':'blue','0000CD':'mediumblue','00008B':'darkblue','000080':'navy','191970':'midnightblue',
                'FFF8DC':'cornsilk','FFEBCD':'blanchedalmond','FFE4C4':'bisque','FFDEAD':'navajowhite','F5DEB3':'wheat',
                'DEB887':'burlywood','D2B48C':'tan','BC8F8F':'rosybrown','F4A460':'sandybrown','DAA520':'goldenrod',
                'B8860B':'darkgoldenrod','CD853F':'peru','D2691E':'chocolate','8B4513':'saddlebrown','A0522D':'sienna',
                'A52A2A':'brown','800000':'maroon','FFFFFF':'white','FFFAFA':'snow','F0FFF0':'honeydew',
                'F5FFFA':'mintcream','F0FFFF':'azure','F0F8FF':'aliceblue','F8F8FF':'ghostwhite','F5F5F5':'whitesmoke',
                'FFF5EE':'seashell','F5F5DC':'beige','FDF5E6':'oldlace','FFFAF0':'floralwhite','FFFFF0':'ivory',
                'FAEBD7':'antiquewhite','FAF0E6':'linen','FFF0F5':'lavenderblush','FFE4E1':'mistyrose','DCDCDC':'gainsboro',
                'D3D3D3':'lightgray','C0C0C0':'silver','A9A9A9':'darkgray','808080':'gray','696969':'dimgray',
                '778899':'lightslategray','708090':'slategray','2F4F4F':'darkslategray','000000':'black'
            };
            
            hex = hex.toUpperCase().replace('#','');
            if(colors[hex]) return colors[hex];
            
            const rgb = parseInt(hex, 16);
            const r = (rgb >> 16) & 0xff;
            const g = (rgb >> 8) & 0xff;
            const b = rgb & 0xff;
            
            let minDist = Infinity;
            let closestName = 'color';
            
            for (const [colorHex, colorName] of Object.entries(colors)) {
                const crgb = parseInt(colorHex, 16);
                const cr = (crgb >> 16) & 0xff;
                const cg = (crgb >> 8) & 0xff;
                const cb = crgb & 0xff;
                
                const dist = Math.sqrt((r-cr)**2 + (g-cg)**2 + (b-cb)**2);
                if (dist < minDist) {
                    minDist = dist;
                    closestName = colorName;
                }
            }
            
            return closestName;
        }

        // Gradient builder
        function buildGradient() {
            const type = document.getElementById('grad-type').value;
            const angle = document.getElementById('grad-angle').value;
            const c1 = document.getElementById('grad-color1').value;
            const c2 = document.getElementById('grad-color2').value;
            
            let gradient;
            if (type === 'linear') {
                gradient = `linear-gradient(${angle}deg, ${c1}, ${c2})`;
            } else if (type === 'radial') {
                gradient = `radial-gradient(circle, ${c1}, ${c2})`;
            } else {
                gradient = `conic-gradient(from ${angle}deg, ${c1}, ${c2})`;
            }
            
            return gradient;
        }

        function updateGradientPreview() {
            document.getElementById('grad-preview').style.background = buildGradient();
        }

        function applyGradient() {
            document.getElementById('modal-background').value = buildGradient();
        }

        // Update preview on change
        ['grad-type', 'grad-angle', 'grad-color1', 'grad-color2'].forEach(id => {
            document.getElementById(id).addEventListener('change', updateGradientPreview);
            document.getElementById(id).addEventListener('input', updateGradientPreview);
        });

        let editingTextureName = null;

        // Modal functions
        function addCSSTexture() {
            editingTextureName = null;
            let counter = 1;
            let name = `Texture${counter}`;
            while (textureLibrary[name]) {
                counter++;
                name = `Texture${counter}`;
            }
            document.getElementById('modal-name').value = name;
            document.getElementById('modal-name').disabled = false;
            document.getElementById('modal-background').value = '';
            document.getElementById('is-stackable').checked = false;
            document.querySelector('#css-modal h3').textContent = 'Add Custom Texture';
            updateGradientPreview();
            document.getElementById('css-modal').classList.add('active');
        }

        function editTexture(name) {
            // Use original texture with vars if available, otherwise use resolved
            const texture = originalTextures[name] || textureLibrary[name];
            
            // If it's a simple color, use color picker
            if (typeof texture === 'string' && texture.startsWith('#')) {
                const colorPicker = document.getElementById('quick-color');
                colorPicker.value = texture;
                colorPicker.click();
                colorPicker.onchange = function() {
                    const newColor = this.value;
                    const newName = getColorName(newColor);
                    
                    // Auto-increment if name exists and is different
                    let finalName = newName;
                    let counter = 2;
                    while (textureLibrary[finalName] && finalName !== name) {
                        finalName = `${newName}${counter}`;
                        counter++;
                    }
                    
                    // Update assignments to use new name
                    Object.keys(cubeAssignments).forEach(key => {
                        if (cubeAssignments[key] === name) {
                            cubeAssignments[key] = finalName;
                        }
                    });
                    
                    // Remove old texture and add new one
                    delete textureLibrary[name];
                    delete originalTextures[name];
                    delete textureUsesVars[name];
                    textureLibrary[finalName] = newColor;
                    
                    if (selectedTexture === name) {
                        selectedTexture = finalName;
                        document.getElementById('selected-texture').textContent = `Selected: ${finalName}`;
                    }
                    
                    updateTextureLibrary();
                    updateVisualCube();
                    updateJSON();
                    colorPicker.onchange = null;
                };
                return;
            }
            
            // Otherwise use CSS modal
            editingTextureName = name;
            document.getElementById('modal-name').value = name;
            document.getElementById('modal-name').disabled = true;
            document.querySelector('#css-modal h3').textContent = 'Edit Texture';
            
            // Textures are now always strings - strip url('...') wrapper for editing
            let displayValue = texture || '';
            if (displayValue.startsWith("url('") && displayValue.endsWith("')")) {
                displayValue = displayValue.slice(5, -2);
            } else if (displayValue.startsWith('url("') && displayValue.endsWith('")')  ) {
                displayValue = displayValue.slice(5, -2);
            }
            document.getElementById('modal-background').value = displayValue;
            document.getElementById('is-stackable').checked = textureStackable[name] || false;
            
            document.getElementById('css-modal').classList.add('active');
        }

        function closeModal() {
            document.getElementById('css-modal').classList.remove('active');
        }

        function saveCSSTexture() {
            const name = document.getElementById('modal-name').value.trim();
            if (!name) return;
            
            let textureValue = document.getElementById('modal-background').value.trim();
            if (!textureValue) return;
            
            // Wrap data URIs in url('...') if not already wrapped
            if (textureValue.startsWith('data:') && !textureValue.startsWith('url(')) {
                textureValue = `url('${textureValue}')`;
            }
            
            // Check if texture uses variables
            const hasVars = textureValue.includes('$');
            
            const isStackable = document.getElementById('is-stackable').checked;
            
            if (hasVars) {
                // Store original with vars and resolved version
                originalTextures[name] = textureValue;
                textureUsesVars[name] = true;
                textureLibrary[name] = replaceVars(textureValue, varsLibrary);
            } else {
                // No vars, just store directly
                textureLibrary[name] = textureValue;
                delete originalTextures[name];
                textureUsesVars[name] = false;
            }
            
            textureStackable[name] = isStackable;
            
            // If editing and name changed, update assignments
            if (editingTextureName && editingTextureName !== name) {
                Object.keys(cubeAssignments).forEach(key => {
                    if (cubeAssignments[key] === editingTextureName) {
                        cubeAssignments[key] = name;
                    }
                });
                delete textureLibrary[editingTextureName];
                delete originalTextures[editingTextureName];
                delete textureUsesVars[editingTextureName];
                if (selectedTexture === editingTextureName) {
                    selectedTexture = name;
                }
            }
            
            selectedTexture = name;
            updateTextureLibrary();
            updateVisualCube();
            updateJSON();
            document.getElementById('selected-texture').textContent = `Selected: ${name}`;
            closeModal();
            editingTextureName = null;
        }

        // Close modal on outside click
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                closeModal();
            }
        });

        // Add quick color
        function addQuickColor() {
            const color = document.getElementById('quick-color').value;
            const name = getColorName(color);
            
            // Auto-increment if name exists
            let finalName = name;
            let counter = 2;
            while (textureLibrary[finalName]) {
                finalName = `${name}${counter}`;
                counter++;
            }
            
            textureLibrary[finalName] = color;
            selectedTexture = finalName;
            updateTextureLibrary();
            updateJSON();
            document.getElementById('selected-texture').textContent = `Selected: ${finalName}`;
        }

        // Add image texture
        document.getElementById('image-upload').addEventListener('change', function() {
            const file = this.files[0];
            if (!file) {
                showToast('Please select an image file');
                return;
            }
            
            let name = file.name.split('.')[0];
            
            // Auto-increment if name exists
            let finalName = name;
            let counter = 2;
            while (textureLibrary[finalName]) {
                finalName = `${name}${counter}`;
                counter++;
            }
            name = finalName;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    let width = img.width;
                    let height = img.height;
                    const maxSize = 250;
                    
                    if (width > maxSize || height > maxSize) {
                        if (width > height) {
                            height = (height / width) * maxSize;
                            width = maxSize;
                        } else {
                            width = (width / height) * maxSize;
                            height = maxSize;
                        }
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    const dataUri = canvas.toDataURL('image/jpeg', 0.7);
                    // Store as url('...') format
                    textureLibrary[name] = `url('${dataUri}')`;
                    selectedTexture = name;
                    updateTextureLibrary();
                    updateJSON();
                    document.getElementById('selected-texture').textContent = `Selected: ${name}`;
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            this.value = '';
        });

        // Delete texture
        function deleteTexture(name) {
            delete textureLibrary[name];
            if (selectedTexture === name) {
                selectedTexture = null;
                document.getElementById('selected-texture').textContent = 'No texture selected';
            }
            
            // Remove from assignments
            Object.keys(cubeAssignments).forEach(key => {
                if (cubeAssignments[key] === name) {
                    delete cubeAssignments[key];
                }
            });
            
            updateTextureLibrary();
            updateVisualCube();
            updateJSON();
        }

        // Generate JSON configuration
        function generateConfig() {
            const config = {};
            
            // Separate colors from textures
            const colorsToExport = {};
            const texturesToExport = {};
            
            // Track which textures need sprite vs spread
            const textureUsage = {}; // {textureName: {sprite: bool, spread: bool}}
            
            // Analyze assignments
            Object.entries(cubeAssignments).forEach(([key, textureNameOrArray]) => {
                const textures = Array.isArray(textureNameOrArray) ? textureNameOrArray : [textureNameOrArray];
                
                textures.forEach(textureName => {
                    if (!textureUsage[textureName]) {
                        textureUsage[textureName] = {sprite: false, spread: false};
                    }
                    
                    // Single letter = whole face (sprite), otherwise individual sticker (spread)
                    if (key.length === 1) {
                        textureUsage[textureName].sprite = true;
                    } else {
                        textureUsage[textureName].spread = true;
                    }
                });
            });
            
            // Categorize used textures as colors or textures
            Object.keys(textureUsage).forEach(textureName => {
                const baseTexture = textureUsesVars[textureName] ? originalTextures[textureName] : textureLibrary[textureName];
                
                // If it's a simple color (starts with #), add to vars
                if (typeof baseTexture === 'string' && baseTexture.startsWith('#')) {
                    colorsToExport[textureName] = baseTexture;
                } else {
                    texturesToExport[textureName] = baseTexture;
                }
            });
            
            // Add vars (existing + colors)
            const allVars = { ...varsLibrary, ...colorsToExport };
            if (Object.keys(allVars).length > 0) {
                config.vars = allVars;
            }
            
            // Add stackable definition - only include textures that exist in current cube
            const usedTextures = Object.keys(textureUsage);
            const stackableTextures = Object.keys(textureStackable)
                .filter(name => textureStackable[name] && usedTextures.includes(name));
            if (stackableTextures.length > 0) {
                config.vars = config.vars || {};
                config.vars.__definition = `stackable: ${stackableTextures.join(',')}`;
            }
            
            config.textures = {};
            
            // Generate texture entries with appropriate backgroundSize (only for non-colors)
            Object.entries(texturesToExport).forEach(([textureName, baseTexture]) => {
                const usage = textureUsage[textureName];
                
                if (usage.sprite) {
                    const spriteName = `${textureName}_sprite`;
                    config.textures[spriteName] = {
                        backgroundImage: baseTexture,
                        backgroundSize: '300% 300%'
                    };
                }
                
                if (usage.spread) {
                    const spreadName = `${textureName}_spread`;
                    config.textures[spreadName] = {
                        backgroundImage: baseTexture,
                        backgroundSize: 'cover'
                    };
                }
            });
            
            config.cube = {};
            
            // Build cube assignments
            Object.entries(cubeAssignments).forEach(([key, textureNameOrArray]) => {
                if (Array.isArray(textureNameOrArray)) {
                    // Array of textures
                    config.cube[key] = textureNameOrArray.map(textureName => {
                        const baseTexture = textureLibrary[textureName];
                        // Colors use $varName, textures use textures.name_suffix
                        if (typeof baseTexture === 'string' && baseTexture.startsWith('#')) {
                            return `$${textureName}`;
                        } else {
                            const suffix = key.length === 1 ? '_sprite' : '_spread';
                            return `textures.${textureName}${suffix}`;
                        }
                    });
                } else {
                    const baseTexture = textureLibrary[textureNameOrArray];
                    // Colors use $varName, textures use textures.name_suffix
                    if (typeof baseTexture === 'string' && baseTexture.startsWith('#')) {
                        config.cube[key] = `$${textureNameOrArray}`;
                    } else {
                        const suffix = key.length === 1 ? '_sprite' : '_spread';
                        config.cube[key] = `textures.${textureNameOrArray}${suffix}`;
                    }
                }
            });
            
            return config;
        }



        // Syntax highlight JSON
        function syntaxHighlight(json) {
            json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            return json.replace(/"(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, function (match) {
                let cls = 'number';
                if (/^"/.test(match)) {
                    if (/:$/.test(match)) {
                        cls = 'key';
                    } else {
                        cls = 'string';
                    }
                } else if (/true|false/.test(match)) {
                    cls = 'boolean';
                } else if (/null/.test(match)) {
                    cls = 'null';
                }
                return '<span class="' + cls + '">' + match + '</span>';
            });
        }

        // Update JSON display
        function updateJSON() {
            const config = generateConfig();
            document.getElementById('json-output').value = JSON.stringify(config, null, 2);
            

        }



        // Export configuration
        function exportConfig() {
            const config = generateConfig();
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'cube-texture-config.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Import modal functions
        function openImportModal() {
            document.getElementById('import-json').value = '';
            document.getElementById('import-modal').classList.add('active');
        }

        function closeImportModal() {
            document.getElementById('import-modal').classList.remove('active');
        }

        function loadFromJSON() {
            let jsonText = document.getElementById('import-json').value.trim();
            if (!jsonText) {
                showToast('Please paste JSON configuration');
                return;
            }
            
            try {
                // Decode HTML entities (both named and numeric)
                const doc = new DOMParser().parseFromString(jsonText, 'text/html');
                jsonText = doc.documentElement.textContent;
                
                // Strip comments properly (avoid removing // inside strings)
                function stripJsonComments(json) {
                    let result = '';
                    let inString = false;
                    let inComment = false;
                    let inBlockComment = false;
                    for (let i = 0; i < json.length; i++) {
                        const char = json[i];
                        const next = json[i + 1] || '';
                        if (inBlockComment) {
                            if (char === '*' && next === '/') {
                                inBlockComment = false;
                                i++;
                            }
                            continue;
                        }
                        if (inComment) {
                            if (char === '\n') {
                                inComment = false;
                                result += char;
                            }
                            continue;
                        }
                        if (char === '"' && (i === 0 || json[i - 1] !== '\\')) {
                            inString = !inString;
                            result += char;
                            continue;
                        }
                        if (!inString) {
                            if (char === '/' && next === '/') {
                                inComment = true;
                                i++;
                                continue;
                            }
                            if (char === '/' && next === '*') {
                                inBlockComment = true;
                                i++;
                                continue;
                            }
                        }
                        result += char;
                    }
                    return result;
                }
                
                jsonText = stripJsonComments(jsonText);
                const config = JSON.parse(jsonText);
                loadConfig(config);
                closeImportModal();
                showToast('Configuration loaded successfully!');
            } catch (err) {
                showToast('Invalid JSON: ' + err.message);
            }
        }

        // Variable management
        function updateVarsList() {
            const varsList = document.getElementById('vars-list');
            varsList.innerHTML = '';
            
            Object.entries(varsLibrary).forEach(([name, value]) => {
                const varItem = document.createElement('div');
                varItem.style.cssText = 'display: flex; gap: 5px; margin: 5px 0; align-items: center; background: #f8f9fa; padding: 5px; border-radius: 4px;';
                
                const varText = document.createElement('div');
                varText.style.cssText = 'flex: 1; font-size: 12px; font-family: monospace; cursor: pointer; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;';
                varText.textContent = `$${name} = ${value}`;
                varText.title = `$${name} = ${value}`;
                varText.onclick = () => editVar(name);
                
                const editBtn = document.createElement('button');
                editBtn.textContent = 'Edit';
                editBtn.style.cssText = 'background: #007cba; padding: 2px 8px; font-size: 11px;';
                editBtn.onclick = () => editVar(name);
                
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '×';
                deleteBtn.style.cssText = 'background: #dc3545; padding: 2px 8px; font-size: 14px;';
                deleteBtn.onclick = () => deleteVar(name);
                
                varItem.appendChild(varText);
                varItem.appendChild(editBtn);
                varItem.appendChild(deleteBtn);
                varsList.appendChild(varItem);
            });
        }

        let editingVarName = null;

        function addVar() {
            editingVarName = null;
            document.getElementById('var-name').value = '';
            document.getElementById('var-value').value = '';
            document.getElementById('var-name').disabled = false;
            document.querySelector('#var-modal h3').textContent = 'Add Variable';
            document.getElementById('var-modal').classList.add('active');
        }

        function editVar(name) {
            editingVarName = name;
            document.getElementById('var-name').value = name;
            document.getElementById('var-value').value = varsLibrary[name];
            document.getElementById('var-name').disabled = true;
            document.querySelector('#var-modal h3').textContent = 'Edit Variable';
            document.getElementById('var-modal').classList.add('active');
        }

        function closeVarModal() {
            document.getElementById('var-modal').classList.remove('active');
        }

        function saveVar() {
            const name = document.getElementById('var-name').value.trim();
            const value = document.getElementById('var-value').value.trim();
            
            if (!name || !value) {
                showToast('Please enter both name and value');
                return;
            }
            
            varsLibrary[name] = value;
            
            // Re-resolve textures that use this var
            Object.entries(originalTextures).forEach(([texName, texValue]) => {
                if (textureUsesVars[texName]) {
                    textureLibrary[texName] = replaceVars(texValue, varsLibrary);
                }
            });
            
            updateVarsList();
            updateTextureLibrary();
            updateVisualCube();
            updateJSON();
            closeVarModal();
            showToast(editingVarName ? `Variable $${name} updated` : `Variable $${name} added`);
            editingVarName = null;
        }

        function deleteVar(name) {
            delete varsLibrary[name];
            
            // Re-resolve textures that use vars
            Object.entries(originalTextures).forEach(([texName, texValue]) => {
                if (textureUsesVars[texName]) {
                    textureLibrary[texName] = replaceVars(texValue, varsLibrary);
                }
            });
            
            updateVarsList();
            updateTextureLibrary();
            updateVisualCube();
            updateJSON();
            showToast(`Variable $${name} deleted`);
        }

        // Replace variables in a value
        function replaceVars(value, vars) {
            if (typeof value === 'string') {
                return value.replace(/\$([a-zA-Z_][a-zA-Z0-9_]*)/g, (match, varName) => {
                    return vars[varName] !== undefined ? vars[varName] : match;
                });
            } else if (typeof value === 'object' && value !== null) {
                const result = {};
                for (const [key, val] of Object.entries(value)) {
                    result[key] = replaceVars(val, vars);
                }
                return result;
            }
            return value;
        }

        // Load configuration
        function loadConfig(config) {
            // Clear existing data
            varsLibrary = {};
            textureLibrary = {};
            originalTextures = {};
            textureUsesVars = {};
            cubeAssignments = {};
            
            // Load vars
            if (config.vars) {
                varsLibrary = { ...config.vars };
                
                // Parse stackable definition
                if (config.vars.__definition && config.vars.__definition.startsWith('stackable:')) {
                    const stackableList = config.vars.__definition.slice(10).trim();
                    if (stackableList) {
                        stackableList.split(',').forEach(name => {
                            textureStackable[name.trim()] = true;
                        });
                    }
                    delete varsLibrary.__definition;
                }
                
                // Add color vars to texture library
                Object.entries(config.vars).forEach(([name, value]) => {
                    if (typeof value === 'string' && value.startsWith('#')) {
                        textureLibrary[name] = value;
                    }
                });
            }
            
            // Extract base textures from texture entries (remove _sprite/_spread suffixes)
            const baseTextures = new Map();
            if (config.textures) {
                Object.entries(config.textures).forEach(([name, value]) => {
                    // Extract backgroundImage from object or use value directly
                    let bgImage = value;
                    if (typeof value === 'object' && value.backgroundImage) {
                        bgImage = value.backgroundImage;
                    }
                    
                    // Remove _sprite or _spread suffix to get base name
                    const baseName = name.replace(/_(sprite|spread)$/, '');
                    
                    if (!baseTextures.has(baseName)) {
                        const hasVars = JSON.stringify(bgImage).includes('$');
                        if (hasVars) {
                            originalTextures[baseName] = bgImage;
                            textureUsesVars[baseName] = true;
                            textureLibrary[baseName] = replaceVars(bgImage, varsLibrary);
                        } else {
                            textureLibrary[baseName] = bgImage;
                            textureUsesVars[baseName] = false;
                        }
                        baseTextures.set(baseName, true);
                    }
                });
            }
            
            // Load cube assignments (strip _sprite/_spread and $ from references)
            if (config.cube) {
                Object.entries(config.cube).forEach(([key, value]) => {
                    if (Array.isArray(value)) {
                        // Array of texture references
                        cubeAssignments[key] = value.map(ref => {
                            if (ref.startsWith('textures.')) {
                                return ref.slice(9).replace(/_(sprite|spread)$/, '');
                            } else if (ref.startsWith('$')) {
                                return ref.slice(1);
                            }
                            return ref;
                        });
                    } else if (value.startsWith('textures.')) {
                        let textureName = value.slice(9);
                        textureName = textureName.replace(/_(sprite|spread)$/, '');
                        cubeAssignments[key] = textureName;
                    } else if (value.startsWith('$')) {
                        cubeAssignments[key] = value.slice(1);
                    }
                });
            }
            
            // Update display
            updateTextureLibrary();
            updateVisualCube();
            updateVarsList();
            updateJSON();
        }

        // Update visual cube based on assignments
        function updateVisualCube() {
            // Reset all stickers first
            document.querySelectorAll('.cube-sticker').forEach(sticker => {
                sticker.style.backgroundColor = '#888';
                sticker.style.backgroundImage = 'none';
            });
            
            Object.entries(cubeAssignments).forEach(([key, textureNameOrArray]) => {
                if (key.length === 1) {
                    // Whole face
                    for (let i = 0; i < 9; i++) {
                        const stickerEl = document.querySelector(`[data-face="${key}"][data-sticker="${i}"]`);
                        if (stickerEl) applyTextureToElement(stickerEl, textureNameOrArray, true);
                    }
                } else {
                    // Individual sticker
                    const face = key[0];
                    const sticker = key.slice(1);
                    const stickerEl = document.querySelector(`[data-face="${face}"][data-sticker="${sticker}"]`);
                    if (stickerEl) applyTextureToElement(stickerEl, textureNameOrArray, false);
                }
            });
        }







        // Zoom and pan
        function updateTransform() {
            const wrapper = document.getElementById('cube-wrapper');
            wrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
        }

        document.getElementById('cube-panel').addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            scale = Math.max(0.5, Math.min(3, scale * delta));
            updateTransform();
        }, { passive: false });

        document.getElementById('cube-panel').addEventListener('mousedown', (e) => {
            if (e.target.closest('.cube-face')) return;
            isPanning = true;
            startX = e.clientX - panX;
            startY = e.clientY - panY;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            panX = e.clientX - startX;
            panY = e.clientY - startY;
            updateTransform();
        });

        document.addEventListener('mouseup', () => {
            isPanning = false;
        });

        // Touch support
        let initialDistance = 0;
        let initialScale = 1;

        document.getElementById('cube-panel').addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                if (e.target.closest('.cube-face')) return;
                isPanning = true;
                const touch = e.touches[0];
                startX = touch.clientX - panX;
                startY = touch.clientY - panY;
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                initialDistance = Math.sqrt(dx * dx + dy * dy);
                initialScale = scale;
            }
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1 && isPanning) {
                const touch = e.touches[0];
                panX = touch.clientX - startX;
                panY = touch.clientY - startY;
                updateTransform();
                e.preventDefault();
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                scale = Math.max(0.5, Math.min(3, initialScale * (distance / initialDistance)));
                updateTransform();
                e.preventDefault();
            }
        }, { passive: false });

        document.addEventListener('touchend', () => {
            isPanning = false;
        });

        // ==================== PARENT COMMUNICATION ====================

        let isEmbedded = false;
        let parentWindow = null;

        function setupParentCommunication() {
            isEmbedded = window.self !== window.top;
            if (isEmbedded) {
                parentWindow = window.parent;
                
                window.addEventListener('message', (event) => {
                    const { type, payload } = event.data;
                    
                    if (type === 'INIT_EDITOR' && payload.config) {
                        loadConfig(payload.config);
                    }
                });
                
                parentWindow.postMessage({ type: 'EDITOR_READY' }, '*');
                
                // Trigger auto-import immediately when embedded
                setTimeout(() => {
                    try {
                        const parentConfig = window.parent.document.getElementById('customConfig').value;
                        if (parentConfig.trim()) {
                            document.getElementById('import-json').value = parentConfig;
                            loadFromJSON();
                        }
                    } catch (e) {
                        console.log('Could not access parent config:', e);
                    }
                }, 100);
            }
        }

        function sendToParent(type, payload) {
            if (window.parent !== window) {
                window.parent.postMessage({ type, payload }, '*');
            }
        }

        // Override updateJSON to send updates to parent
        const originalUpdateJSON = updateJSON;
        updateJSON = function() {
            originalUpdateJSON();
            const config = generateConfig();
            sendToParent('UPDATE_CONFIG', { config });
        };

        function closeEditorModal() {
            sendToParent('CLOSE_EDITOR', {});
        }

        // Expose method to parent window
        window.triggerImportFromParent = function() {
            try {
                const parentConfig = window.parent.document.getElementById('customConfig').value;
                if (parentConfig.trim()) {
                    document.getElementById('import-json').value = parentConfig;
                    loadFromJSON();
                }
            } catch (e) {
                console.log('Could not access parent config:', e);
            }
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            setupParentCommunication();
            initCube();
            initDefaultTextures();
            setMode('face');
            updateVarsList();
            
            if (window.parent !== window) {
                document.getElementById('close-editor-btn').style.display = 'block';
            }
            

        });
        
        // Also run on window load for iframe reloads
        window.addEventListener('load', () => {
            if (window.parent !== window) {
                setupParentCommunication();
            }
        });
    </script>
</body>
</html>